<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Online Car Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, onSnapshot, deleteDoc, writeBatch, serverTimestamp, query, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBWnSCQgMq0YoU14UCU5eg7nWZKwKSHuxA",
            authDomain: "onlinecargame-4fe6a.firebaseapp.com",
            projectId: "onlinecargame-4fe6a",
            storageBucket: "onlinecargame-4fe6a.firebasestorage.app",
            messagingSenderId: "1077083880146",
            appId: "1:1077083880146:web:3e4c72737920de9c6f0b0b",
            measurementId: "G-P86BC73C8P"
        };

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- EXPOSE FIREBASE FUNCTIONS TO GLOBAL SCOPE FOR GAME LOOP ---
        window.updateDoc = updateDoc;
        window.serverTimestamp = serverTimestamp;
        window.doc = doc;
        window.writeBatch = writeBatch;
        window.deleteDoc = deleteDoc;

        window.netState = {
            db, auth, user: null, currentRoomId: null, isHost: false,
            unsubRoom: null, unsubPlayers: null, unsubEntities: null, unsubGameState: null,
            lastUpdateSent: 0, playerMap: {}, connectedPlayersList: []
        };

        const statusEl = document.getElementById('connection-status');
        const colRooms = collection(db, 'artifacts', appId, 'public', 'data', 'rooms');
        const colPlayers = collection(db, 'artifacts', appId, 'public', 'data', 'players');
        const colEntities = collection(db, 'artifacts', appId, 'public', 'data', 'entities');
        const colGameStates = collection(db, 'artifacts', appId, 'public', 'data', 'gamestates');

        // --- AUTH FIX: Fallback to Anonymous if Custom Token Mismatches ---
        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try {
                        // Try to use the environment token first
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } catch (tokenError) {
                        console.warn("Token mismatch (expected for custom Firebase config), falling back to Anonymous Auth:", tokenError);
                        await signInAnonymously(auth);
                    }
                } else {
                    await signInAnonymously(auth);
                }
            } catch (e) {
                console.error("Auth Error:", e);
                statusEl.textContent = "Auth Failed";
                statusEl.className = "text-red-500 font-bold text-sm";
            }
        };
        
        onAuthStateChanged(auth, (user) => {
            if (user) {
                window.netState.user = user;
                statusEl.textContent = "â— Online";
                statusEl.className = "text-green-400 font-bold text-sm";
                document.getElementById('login-container').classList.remove('opacity-50', 'pointer-events-none');
            } else {
                statusEl.textContent = "â—‹ Connecting...";
                statusEl.className = "text-yellow-400 font-bold text-sm";
                document.getElementById('login-container').classList.add('opacity-50', 'pointer-events-none');
            }
        });
        initAuth();

        // --- NETWORKING ---
        window.hostConfig = { mode: '1v1', type: 'timed', duration: 120, scoreTarget: 5 };

        window.finalizeCreateRoom = async () => {
            const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
            try {
                await setDoc(doc(colRooms, roomId), {
                    ...window.hostConfig,
                    status: 'lobby', hostId: window.netState.user.uid, createdAt: serverTimestamp()
                });
                document.getElementById('lobby-code').innerText = roomId;
                window.switchScreen('screen-lobby');
                await joinRoomLogic(roomId, window.username, true);
                return roomId;
            } catch(e) { console.error(e); alert("Error creating room"); }
        };

        window.joinRoom = async (code) => {
            const roomId = code.trim().toUpperCase();
            try {
                const roomSnap = await getDoc(doc(colRooms, roomId));
                if (!roomSnap.exists()) throw new Error("Room not found");
                document.getElementById('lobby-code').innerText = roomId;
                window.switchScreen('screen-lobby');
                await joinRoomLogic(roomId, window.username, false);
                return roomId;
            } catch(e) { alert(e.message); throw e; }
        };

        async function joinRoomLogic(roomId, username, isHost) {
            const uid = window.netState.user.uid;
            const docId = `${roomId}_${uid}`;
            try {
                await setDoc(doc(colPlayers, docId), {
                    roomId: roomId, userId: uid, username: username, isHost: isHost,
                    isReady: false, slotIndex: -1, team: 'spectator', joinedAt: serverTimestamp()
                });
                subscribeToRoom(roomId);
            } catch(e) { console.error(e); }
        }

        // --- LEAVE GAME FIX ---
        window.leaveRoom = async () => {
            const roomId = window.netState.currentRoomId;
            if (!roomId) { window.resetToMenu(); return; }
            const uid = window.netState.user.uid;
            
            // Unsubscribe from listeners FIRST
            if(window.netState.unsubRoom) window.netState.unsubRoom();
            if(window.netState.unsubPlayers) window.netState.unsubPlayers();
            if(window.netState.unsubEntities) window.netState.unsubEntities();
            if(window.netState.unsubGameState) window.netState.unsubGameState();
            
            try { 
                // If user is host, delete the room, gamestate, and all player/entity docs
                if (window.netState.isHost) {
                    const batch = window.writeBatch(db);
                    
                    // 1. Delete Room
                    batch.delete(doc(colRooms, roomId));
                    
                    // 2. Delete GameState
                    batch.delete(doc(colGameStates, roomId));
                    
                    // 3. Delete all players in the room
                    Object.keys(window.netState.playerMap).forEach(playerId => {
                        batch.delete(doc(colPlayers, `${roomId}_${playerId}`));
                    });
                    
                    // 4. Delete all entity docs for those players
                     Object.keys(window.netState.playerMap).forEach(playerId => {
                        batch.delete(doc(colEntities, `${roomId}_${playerId}`));
                    });
                    
                    await batch.commit();
                } else {
                    // Just delete this one player's doc
                    await window.deleteDoc(doc(colPlayers, `${roomId}_${uid}`)); 
                }
            } catch(e) { 
                console.error("Error during leaveRoom cleanup:", e);
            }
            
            window.resetToMenu(); // This resets local state and UI
        };

        window.resetToMenu = () => {
            window.netState.currentRoomId = null;
            window.netState.isHost = false;
            window.netState.playerMap = {};
            window.netState.connectedPlayersList = [];
            document.getElementById('app').classList.remove('in-game');
            window.switchScreen('screen-start');
            window.resetGameObjects();
        };

        window.toggleReady = async () => {
            const uid = window.netState.user.uid;
            const p = window.netState.playerMap[uid];
            if(!p || p.slotIndex === -1) return;
            try { await updateDoc(doc(colPlayers, `${window.netState.currentRoomId}_${uid}`), { isReady: !p.isReady }); } catch(e){}
        };

        window.claimSlot = async (idx) => {
            const uid = window.netState.user.uid;
            const team = idx % 2 === 0 ? 'left' : 'right';
            try { await updateDoc(doc(colPlayers, `${window.netState.currentRoomId}_${uid}`), { slotIndex: idx, team: team, isReady: false }); } catch(e){}
        };

        window.startGame = async () => {
            try { await updateDoc(doc(colRooms, window.netState.currentRoomId), { status: 'playing' }); } catch(e){}
        };

        window.sendGameUpdate = async (myEntities, ballData, gameData) => {
            const now = Date.now();
            if (now - window.netState.lastUpdateSent < 50) return; // 20fps
            window.netState.lastUpdateSent = now;
            
            const roomId = window.netState.currentRoomId;
            const uid = window.netState.user.uid;
            if (!roomId || !uid) return;

            const batch = writeBatch(db);
            const entId = `${roomId}_${uid}`;
            
            if (myEntities) {
                batch.set(doc(colEntities, entId), { roomId, userId: uid, data: myEntities, ts: serverTimestamp() });
            }
            
            if (ballData || gameData) {
                const update = { roomId };
                if(ballData) update.ball = ballData;
                if(gameData) { 
                    if(gameData.scores) update.scores = gameData.scores; 
                    if(gameData.timer !== undefined) update.timer = gameData.timer; 
                    if(gameData.paused !== undefined) update.paused = gameData.paused;
                    if(gameData.winner) update.winner = gameData.winner;
                    if(gameData.pads) update.pads = gameData.pads; 
                }
                batch.set(doc(colGameStates, roomId), update, { merge: true });
            }
            try { await batch.commit(); } catch(e) {}
        };

        function subscribeToRoom(roomId) {
            window.netState.currentRoomId = roomId;
            window.netState.unsubRoom = onSnapshot(doc(colRooms, roomId), (snap) => {
                if(!snap.exists()) { 
                    setTimeout(() => {
                        if (window.netState.currentRoomId) { 
                            window.leaveRoom();
                        }
                    }, 100);
                    return; 
                }
                const data = snap.data();
                window.updateLobbyUI(data);
                if (data.status === 'playing' && window.gameState !== 'playing') window.initGame(data);
            }, (err) => console.log(err));

            const qPlayers = query(colPlayers, where('roomId', '==', roomId));
            window.netState.unsubPlayers = onSnapshot(qPlayers, (snap) => {
                const list = [];
                snap.forEach(d => list.push({...d.data(), id: d.data().userId}));
                window.netState.playerMap = list.reduce((acc,p) => ({...acc, [p.id]:p}), {});
                window.netState.connectedPlayersList = list.map(p => p.id).sort();
                const me = list.find(p => p.id === window.netState.user.uid);
                if(me) window.netState.isHost = me.isHost;
                window.renderSlots(list);
            }, (err) => console.log(err));

            const qEntities = query(colEntities, where('roomId', '==', roomId));
            window.netState.unsubEntities = onSnapshot(qEntities, (snap) => {
                snap.forEach(d => {
                    if(d.data().userId !== window.netState.user.uid) window.handleRemoteEntityUpdate(d.data().data);
                });
            }, (err) => console.log(err));

            window.netState.unsubGameState = onSnapshot(doc(colGameStates, roomId), (snap) => {
                if(snap.exists()) window.handleGameStateUpdate(snap.data());
            }, (err) => console.log(err));
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body { 
            background: #111827; color: white; font-family: 'Inter', sans-serif; 
            overflow: hidden; margin: 0; display: flex; align-items: center; justify-content: center; height: 100vh;
        }
        #app { 
            width: 95vw; max-width: 1100px; 
            height: 90vh;
            position: relative; background: #1f2937; border-radius: 16px; 
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); overflow: hidden; display: flex; flex-direction: column;
            transition: all 0.5s ease; 
        }
        
        #app.in-game {
            max-width: 1400px;
            width: 98vw;
            height: auto;
            aspect-ratio: 16/9;
            max-height: 95vh;
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: -webkit-optimize-contrast; }
        
        .screen { position: absolute; inset: 0; display: none; flex-direction: column; align-items: center; justify-content: center; background: #1f2937; z-index: 10; }
        .screen.active { display: flex; }
        
        .btn { padding: 14px 28px; border-radius: 12px; font-weight: 900; text-transform: uppercase; transition: 0.2s; cursor: pointer; border: none; font-size: 1.1rem; width: 200px; }
        .btn-primary { background: #fbbf24; color: #1f2937; }
        .btn-primary:hover { background: #f59e0b; transform: translateY(-2px); }
        .btn-outline { border: 3px solid #4b5563; color: #d1d5db; background: transparent; }
        .btn-outline:hover { border-color: #fbbf24; color: #fbbf24; }
        .btn-danger { background: #ef4444; color: white; }
        
        .inp-lg { 
            background: #374151; border: 3px solid #4b5563; padding: 16px; border-radius: 12px; 
            color: white; text-align: center; font-size: 1.5rem; font-weight: bold; width: 100%; max-width: 400px;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .inp-lg:focus { outline: none; border-color: #fbbf24; }

        .slot { 
            width: 100%; height: 80px; border: 2px dashed #4b5563; border-radius: 8px; 
            display: flex; align-items: center; justify-content: space-between; padding: 0 20px;
            cursor: pointer; transition: 0.2s; position: relative; background: rgba(0,0,0,0.2);
        }
        .slot:hover { border-color: #9ca3af; background: rgba(255,255,255,0.05); }
        .slot.filled { border-style: solid; cursor: default; }
        .slot.filled.blue { border-color: #3b82f6; background: linear-gradient(90deg, rgba(30,58,138,0.8), transparent); }
        .slot.filled.red { border-color: #ef4444; background: linear-gradient(90deg, rgba(127,29,29,0.8), transparent); }
        .slot.ai { border: 1px solid rgba(255,255,255,0.1); opacity: 0.5; }
        
        .mode-card {
            width: 120px; height: 120px; background: #374151; border: 3px solid #4b5563;
            display: flex; align-items: center; justify-content: center; border-radius: 16px;
            font-size: 1.5rem; font-weight: 900; cursor: pointer; transition: 0.2s; text-align: center; flex-direction: column; gap: 5px;
        }
        .mode-card:hover { border-color: #fbbf24; color: #fbbf24; transform: scale(1.05); }
        .mode-card span { font-size: 0.8rem; font-weight: normal; opacity: 0.7; }

        #bottom-hud {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 80px;
            background: linear-gradient(to top, #111827, transparent);
            display: flex; align-items: flex-end; justify-content: space-between;
            padding: 10px 30px; pointer-events: none; z-index: 20;
        }
        .score-box { font-size: 2.5rem; font-weight: 900; text-shadow: 0 2px 8px rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; line-height: 1; }
        .timer-box { font-family: monospace; font-size: 2rem; font-weight: bold; color: white; text-shadow: 0 2px 4px black; margin-bottom: 10px; transition: all 0.3s ease; }
        .timer-box.points { display: none; } /* HIDDEN IN POINTS MODE */
        .timer-box.glow-red { color: #ef4444; text-shadow: 0 0 20px #ef4444; transform: scale(1.5); }
        .timer-box.countdown { color: #ef4444; font-size: 6rem; position: absolute; bottom: 200px; left: 50%; transform: translateX(-50%); text-shadow: 4px 4px 0 #000; }
        
        .boost-container {
            width: 200px; height: 20px; background: #374151; border: 2px solid #4b5563;
            border-radius: 10px; overflow: hidden; margin-bottom: 15px; position: relative;
        }
        .boost-fill { height: 100%; background: linear-gradient(90deg, #f59e0b, #fbbf24); width: 100%; transition: width 0.1s linear; }
        .boost-text { position: absolute; top: 0; left: 0; width: 100%; text-align: center; font-size: 0.7rem; font-weight: bold; color: black; line-height: 18px; }
        
        #goal-flash { display: none !important; }

    </style>
</head>
<body>

<div id="app">
    <!-- Status Bar -->
    <div class="absolute top-4 left-4 z-50 flex gap-4 items-center">
        <div class="bg-gray-900/80 px-3 py-1 rounded-full backdrop-blur-sm border border-gray-700">
            <span id="connection-status" class="font-mono tracking-wider text-xs">Initializing...</span>
        </div>
    </div>

    <!-- SCREEN: START -->
    <div id="screen-start" class="screen active text-center">
        <h1 class="text-7xl font-black text-yellow-400 mb-2 tracking-tighter italic" style="text-shadow: 4px 4px 0 #000;">ONLINE <span class="text-white">CAR GAME</span></h1>
        <p class="text-gray-400 mb-10 tracking-widest text-sm font-bold uppercase">Made by Eric</p>
        
        <div id="login-container" class="flex flex-col items-center w-full opacity-50 pointer-events-none transition-opacity duration-500">
            <div class="mb-2 w-full max-w-[400px] text-left text-gray-500 text-xs font-bold ml-2">NAME</div>
            <input type="text" id="inp-name" class="inp-lg mb-6" placeholder="ENTER NAME" maxlength="12">
            <div id="name-error" class="h-6 text-red-500 font-bold text-sm mb-4 opacity-0 transition-opacity">Name too short (3+ chars)</div>
            
            <div class="flex flex-col gap-4 w-full items-center">
                <button class="btn btn-primary shadow-lg shadow-yellow-500/20" onclick="goToModeSelect()">CREATE ROOM</button>
                <button class="btn btn-outline" onclick="goToJoin()">JOIN ROOM</button>
                <button class="btn btn-secondary mt-4" style="width: auto; padding: 10px 20px; font-size: 0.8rem; border: 1px solid #4b5563;" onclick="window.location.href='https://ccpspy.github.io/cargame/'">PLAY OFFLINE MODE</button>
            </div>
        </div>
    </div>

    <!-- SCREEN: MODE SELECT -->
    <div id="screen-mode" class="screen">
        <h2 class="text-4xl font-black mb-10 italic text-white">SELECT TEAM SIZE</h2>
        <div class="flex gap-6 mb-10">
            <div class="mode-card" onclick="setHostMode('1v1')">1v1 <span>2 Players</span></div>
            <div class="mode-card" onclick="setHostMode('2v2')">2v2 <span>4 Players</span></div>
            <div class="mode-card" onclick="setHostMode('3v3')">3v3 <span>6 Players</span></div>
        </div>
        <button class="btn btn-outline" onclick="switchScreen('screen-start')">BACK</button>
    </div>

    <!-- SCREEN: TYPE SELECT -->
    <div id="screen-type" class="screen">
        <h2 class="text-4xl font-black mb-10 italic text-white">GAME TYPE</h2>
        <div class="flex gap-6 mb-10">
            <div class="mode-card" onclick="setHostType('timed')">TIMED <span>Race against clock</span></div>
            <div class="mode-card" onclick="setHostType('points')">POINTS <span>First to score</span></div>
        </div>
        <button class="btn btn-outline" onclick="switchScreen('screen-mode')">BACK</button>
    </div>

    <!-- SCREEN: LIMIT SELECT -->
    <div id="screen-limit" class="screen">
        <h2 class="text-4xl font-black mb-10 italic text-white" id="limit-title">DURATION</h2>
        <div class="flex flex-wrap gap-6 mb-10 justify-center" id="limit-buttons"></div>
        <button class="btn btn-outline" onclick="switchScreen('screen-type')">BACK</button>
    </div>

    <!-- SCREEN: JOIN INPUT -->
    <div id="screen-join" class="screen">
        <h2 class="text-3xl font-black mb-6">JOIN FREQUENCY</h2>
        <input type="text" id="inp-room-code" class="inp-lg mb-6" placeholder="ROOM CODE">
        <div class="flex gap-4">
            <button class="btn btn-outline" onclick="switchScreen('screen-start')">BACK</button>
            <button class="btn btn-primary" onclick="joinRoomAction()">CONNECT</button>
        </div>
    </div>

    <!-- SCREEN: LOBBY -->
    <div id="screen-lobby" class="screen">
        <div class="absolute top-4 left-4 flex gap-2" style="top: 60px;">
            <button class="bg-red-500/20 text-red-400 px-4 py-2 rounded-lg text-xs font-bold hover:bg-red-500/40 border border-red-500/30" onclick="window.leaveRoom()">EXIT LOBBY</button>
        </div>
        
        <div class="text-center mb-4">
            <div class="text-xs text-gray-500 font-bold tracking-widest mb-1">FREQUENCY CODE</div>
            <div id="lobby-code" class="text-6xl font-mono font-black text-white select-all tracking-widest" style="text-shadow: 0 0 20px rgba(255,255,255,0.2);">...</div>
        </div>

        <div id="guest-msg" class="text-gray-500 text-sm mb-8 font-mono hidden bg-gray-900 px-4 py-2 rounded-full border border-gray-700">WAITING FOR HOST TO START...</div>

        <div id="lobby-info" class="flex gap-4 mb-6">
            <div class="bg-gray-800 px-4 py-2 rounded text-sm font-bold text-gray-400" id="info-mode">MODE: 1v1</div>
            <div class="bg-gray-800 px-4 py-2 rounded text-sm font-bold text-gray-400" id="info-type">TYPE: TIMED</div>
            <div class="bg-gray-800 px-4 py-2 rounded text-sm font-bold text-gray-400" id="info-limit">LIMIT: 2 MIN</div>
        </div>

        <!-- SLOTS -->
        <div class="flex justify-between w-full px-8 mb-8 h-[300px]">
            <div class="slot-col w-1/2 pr-2" id="col-blue">
                <div class="text-blue-400 font-black text-xl italic mb-2 text-center">BLUE TEAM</div>
                <div id="slots-blue" class="flex flex-col gap-3"></div>
            </div>
            <div class="flex flex-col justify-center items-center">
                <div class="h-full w-px bg-gray-700"></div>
                <div class="py-4 text-gray-600 font-black text-2xl italic">VS</div>
                <div class="h-full w-px bg-gray-700"></div>
            </div>
            <div class="slot-col w-1/2 pl-2" id="col-red">
                <div class="text-red-400 font-black text-xl italic mb-2 text-center">RED TEAM</div>
                <div id="slots-red" class="flex flex-col gap-3"></div>
            </div>
        </div>

        <div class="flex flex-col items-center gap-3">
            <button id="btn-lobby-action" class="btn shadow-xl" onclick="lobbyAction()">JOIN A TEAM</button>
            <button id="btn-host-start" class="btn bg-green-600 hover:bg-green-500 text-white hidden shadow-lg shadow-green-500/20" onclick="window.startGame()">START MATCH</button>
            <p id="host-warning" class="text-red-500 text-xs font-bold hidden">YOU MUST JOIN A TEAM TO START</p>
        </div>
    </div>

    <!-- SCREEN: RESULT -->
    <div id="screen-result" class="screen z-50 bg-gray-900">
        <h1 id="result-title" class="text-8xl font-black italic tracking-tighter mb-2" style="text-shadow: 0 10px 30px rgba(0,0,0,0.5);">VICTORY</h1>
        <div class="flex gap-10 mb-10">
            <div class="flex flex-col items-center">
                <div class="text-blue-500 font-bold text-sm mb-1">BLUE</div>
                <div id="end-score-blue" class="text-6xl font-black text-white">0</div>
            </div>
            <div class="flex flex-col items-center justify-center">
                <div class="text-gray-600 text-4xl font-black italic">-</div>
            </div>
            <div class="flex flex-col items-center">
                <div class="text-red-500 font-bold text-sm mb-1">RED</div>
                <div id="end-score-red" class="text-6xl font-black text-white">0</div>
            </div>
        </div>
        <button class="btn btn-primary" onclick="window.leaveRoom()">BACK TO MENU</button>
    </div>

    <!-- SCREEN: GAME -->
    <div id="screen-game" class="screen">
        <div id="goal-flash">
            <h1 class="text-9xl font-black text-yellow-400 italic tracking-tighter" style="text-shadow: 10px 10px 0 rgba(0,0,0,0.5); -webkit-text-stroke: 4px black;">GOAL!</h1>
        </div>

        <button class="absolute top-4 right-4 z-20 bg-red-900/80 hover:bg-red-700 text-white px-4 py-2 rounded-lg text-xs font-bold border border-red-500/50" onclick="tryExitGame()">EXIT</button>
        
        <canvas id="canvas"></canvas>

        <!-- Bottom HUD -->
        <div id="bottom-hud">
            <div class="score-box text-blue-400">
                <div class="text-xs text-blue-500/70 font-bold tracking-wider">BLUE</div>
                <div id="score-left">0</div>
            </div>
            
            <div class="flex flex-col items-center">
                <div id="game-timer" class="timer-box">00:00</div>
                <div id="boost-bar-container" class="boost-container">
                    <div id="boost-fill" class="boost-fill"></div>
                    <div class="boost-text">BOOST</div>
                </div>
            </div>

            <div class="score-box text-red-400">
                <div class="text-xs text-red-500/70 font-bold tracking-wider">RED</div>
                <div id="score-right">0</div>
            </div>
        </div>
        
        <!-- Modals -->
        <div id="modal-pause" class="absolute inset-0 bg-black/80 hidden z-50 flex flex-col items-center justify-center backdrop-blur-sm">
            <h2 class="text-5xl text-white font-black mb-10 italic">GAME PAUSED</h2>
            <button class="btn btn-primary w-64 mb-6" onclick="pauseGame()">RESUME</button>
        </div>

        <div id="modal-exit" class="absolute inset-0 bg-black/90 hidden z-50 flex flex-col items-center justify-center backdrop-blur-sm">
            <h2 class="text-3xl text-white font-bold mb-4">LEAVE GAME?</h2>
            <p class="text-gray-400 mb-8">You will disconnect from the room.</p>
            <div class="flex gap-4">
                <button class="btn btn-danger w-32" onclick="window.leaveRoom()">LEAVE</button>
                <button class="btn btn-outline w-32" onclick="cancelExit()">CANCEL</button>
            </div>
        </div>
    </div>
</div>

<script>
// --- FIELD & MECHANICS CONSTANTS ---
const FIELD_CONSTANTS = {
    COLOR_FIELD: '#2b2f3d',
    COLOR_BLUE: '#0066cc',
    COLOR_RED: '#cc0000',
    GOAL_HEIGHT: 170,
    GOAL_LINE_WIDTH: 7,
    CANVAS_WIDTH: 1000,
    CANVAS_HEIGHT: 600,
    BALL_RADIUS: 17,
    CAR_WIDTH: 50
};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const keys = {};

window.hostConfig = { mode: '1v1', type: 'timed', duration: 120, scoreTarget: 5 };

// --- STATE ---
let gameState = 'menu';
let roomSettings = {};
let cars = [];
let ball = null;
let boostPads = [];
let remoteEntities = {};
let score = { left: 0, right: 0 };
let lastTime = 0;
let localCar = null;
let gameTimer = 0;
let gameTimerFlashed = false; 
let lastBallHitTime = 0; 

window.onload = () => {
    canvas.width = FIELD_CONSTANTS.CANVAS_WIDTH;
    canvas.height = FIELD_CONSTANTS.CANVAS_HEIGHT;
};

// --- UI FUNCTIONS ---
function switchScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
}
window.switchScreen = switchScreen;

function validateName() {
    const n = document.getElementById('inp-name').value.trim();
    const err = document.getElementById('name-error');
    if(n.length < 3) { err.style.opacity = '1'; return null; }
    err.style.opacity = '0'; return n.toUpperCase(); // --- FIX: Auto Uppercase Input ---
}
function goToModeSelect() { const name = validateName(); if(name) { window.username = name; switchScreen('screen-mode'); } }
function goToJoin() { const name = validateName(); if(name) { window.username = name; switchScreen('screen-join'); } }
function joinRoomAction() { const code = document.getElementById('inp-room-code').value; if(code.length < 1) return alert("Enter Code"); window.joinRoom(code).catch(e => { }); }

// Host Setup Flow
function setHostMode(mode) { window.hostConfig.mode = mode; switchScreen('screen-type'); }
function setHostType(type) {
    window.hostConfig.type = type;
    const container = document.getElementById('limit-buttons');
    container.innerHTML = '';
    const title = document.getElementById('limit-title');
    const options = type === 'timed' 
        ? [{l:'1 MIN', v:60}, {l:'2 MIN', v:120}, {l:'5 MIN', v:300}] 
        : [{l:'3 PTS', v:3}, {l:'5 PTS', v:5}, {l:'10 PTS', v:10}];
    title.innerText = type === 'timed' ? 'SELECT DURATION' : 'SELECT SCORE LIMIT';
    options.forEach(opt => {
        const div = document.createElement('div');
        div.className = 'mode-card'; 
        div.style.width = '120px'; div.style.height = '100px';
        div.innerHTML = opt.l;
        div.onclick = () => finishHostSetup(opt.v);
        container.appendChild(div);
    });
    switchScreen('screen-limit');
}
function finishHostSetup(val) {
    if(window.hostConfig.type === 'timed') window.hostConfig.duration = val;
    else window.hostConfig.scoreTarget = val;
    window.finalizeCreateRoom();
}

function lobbyAction() {
    const uid = window.netState.user.uid;
    const me = window.netState.playerMap[uid];
    if(me && me.slotIndex !== -1) window.toggleReady();
}

function tryExitGame() { document.getElementById('modal-exit').style.display = 'flex'; }
function cancelExit() { document.getElementById('modal-exit').style.display = 'none'; }
function pauseGame() {
    if (!window.netState.isHost) return;
    const modal = document.getElementById('modal-pause');
    const isPaused = modal.style.display === 'flex';
    window.sendGameUpdate(null, null, { paused: !isPaused });
}

window.resetGameObjects = () => {
    gameState = 'menu';
    cars = []; ball = null; boostPads = []; score = {left:0, right:0};
    document.getElementById('lobby-code').innerText = '...';
    document.getElementById('slots-blue').innerHTML = '';
    document.getElementById('slots-red').innerHTML = '';
    document.getElementById('modal-exit').style.display = 'none';
    lastBallHitTime = 0;
};

// --- RENDERERS ---
window.updateLobbyUI = (data) => {
    roomSettings = data;
    document.getElementById('info-mode').innerText = `MODE: ${data.mode}`;
    document.getElementById('info-type').innerText = `TYPE: ${data.type.toUpperCase()}`;
    document.getElementById('info-limit').innerText = `LIMIT: ${data.type==='timed'?(data.duration/60)+' MIN':data.scoreTarget + ' PTS'}`;
};

window.renderSlots = (players) => {
    const slotsBlue = document.getElementById('slots-blue');
    const slotsRed = document.getElementById('slots-red');
    slotsBlue.innerHTML = ''; slotsRed.innerHTML = '';
    
    const mode = (roomSettings && roomSettings.mode) ? roomSettings.mode : '1v1';
    
    const count = mode === '2v2' ? 4 : (mode === '3v3' ? 6 : 2);
    const uid = window.netState.user.uid;
    const me = players.find(p => p.id === uid);
    const btn = document.getElementById('btn-lobby-action');
    
    const startBtn = document.getElementById('btn-host-start');
    const hostWarning = document.getElementById('host-warning');
    
    if(window.netState.isHost) {
        const readyCount = players.filter(p => p.slotIndex !== -1 && p.isReady).length;
        const totalHumans = players.filter(p => p.slotIndex !== -1).length;
        const hostInSlot = me && me.slotIndex !== -1;
        startBtn.style.display = 'block';
        if (hostInSlot && totalHumans > 0 && readyCount === totalHumans) {
            startBtn.disabled = false; startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            hostWarning.style.display = 'none';
        } else {
            startBtn.disabled = true; startBtn.classList.add('opacity-50', 'cursor-not-allowed');
            if (!hostInSlot) hostWarning.style.display = 'block'; else hostWarning.style.display = 'none';
        }
    } else { startBtn.style.display = 'none'; hostWarning.style.display = 'none'; }

    if(me && me.slotIndex !== -1) {
        btn.innerText = me.isReady ? "READY!" : "CLICK TO READY UP";
        btn.className = `btn w-80 shadow-xl ${me.isReady ? 'bg-green-500 hover:bg-green-400 text-white' : 'btn-primary'}`;
    } else {
        btn.innerText = "JOIN A SLOT FIRST";
        btn.className = "btn btn-outline w-80 text-gray-500 border-gray-500 cursor-not-allowed";
    }

    for(let i=0; i<count; i++) {
        const isRed = i % 2 !== 0;
        const container = isRed ? slotsRed : slotsBlue;
        const p = players.find(pl => pl.slotIndex === i);
        const div = document.createElement('div');
        if(p) {
            div.className = `slot filled ${isRed?'red':'blue'}`;
            div.innerHTML = `<div class="flex items-center gap-3"><div class="text-white font-bold text-lg uppercase">${p.username}</div>${p.isHost ? '<span class="text-xxs bg-yellow-500 text-black px-1 rounded font-bold">HOST</span>' : ''}</div><div class="px-2 py-1 rounded text-xs font-bold ${p.isReady ? 'bg-green-500 text-white' : 'bg-yellow-500/50 text-yellow-100'}">${p.isReady ? 'READY' : 'WAITING'}</div>`;
        } else {
            div.className = "slot ai";
            div.innerHTML = `<div class="text-gray-400 font-bold flex items-center gap-2"><span>ðŸ¤–</span> AI BOT</div><div class="text-xs text-gray-500 font-bold border border-gray-600 px-2 py-1 rounded hover:bg-gray-700 hover:text-white">JOIN</div>`;
            div.onclick = () => window.claimSlot(i);
        }
        container.appendChild(div);
    }
};

// --- EXTRACTED MECHANICS ---

function drawField(ctx, canvas) {
    ctx.fillStyle = FIELD_CONSTANTS.COLOR_FIELD;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    let goalHeight = FIELD_CONSTANTS.GOAL_HEIGHT;
    let playerGoalTop = canvas.height / 2 - goalHeight / 2;
    let playerGoalBottom = canvas.height / 2 + goalHeight / 2;
    ctx.fillStyle = 'rgba(0, 102, 204, 0.2)';
    ctx.fillRect(0, playerGoalTop, 20, goalHeight);
    ctx.fillStyle = 'rgba(204, 0, 0, 0.2)';
    ctx.fillRect(canvas.width - 20, playerGoalTop, 20, goalHeight);
    ctx.strokeStyle = "#dcdcdc"; ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, 80, 0, Math.PI * 2); ctx.stroke();
    ctx.strokeStyle = FIELD_CONSTANTS.COLOR_BLUE; ctx.lineWidth = FIELD_CONSTANTS.GOAL_LINE_WIDTH;
    ctx.beginPath(); ctx.moveTo(0, playerGoalTop); ctx.lineTo(0, playerGoalBottom); ctx.stroke();
    ctx.strokeStyle = FIELD_CONSTANTS.COLOR_RED;
    ctx.beginPath(); ctx.moveTo(canvas.width, playerGoalTop); ctx.lineTo(canvas.width, playerGoalBottom); ctx.stroke();
}

function checkGoal(ball, canvas) {
    let goalHeight = FIELD_CONSTANTS.GOAL_HEIGHT;
    // --- FIX: Use Inclusive checks (>=, <=) to catch boundary cases ---
    if (ball.y >= canvas.height/2 - goalHeight/2 && ball.y <= canvas.height/2 + goalHeight/2) {
        if (ball.x - ball.radius <= 0) return 'right';
        if (ball.x + ball.radius >= canvas.width) return 'left';
    }
    return null;
}

// --- ENTITIES ---
class BoostPad {
    constructor(x, y) { this.x=x; this.y=y; this.active=true; this.cooldown=0; this.radius=15; }
    update(dt) { if(!this.active) { this.cooldown-=dt; if(this.cooldown<=0) this.active=true; } }
    draw() {
        ctx.save(); ctx.globalAlpha = this.active ? 1 : 0.3;
        ctx.fillStyle = '#fbbf24'; ctx.shadowBlur = this.active ? 10 : 0; ctx.shadowColor = '#fbbf24';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius*0.6, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }
}

class Car {
    constructor(id, x, y, angle, team, isLocal, isAI, ownerId) {
        this.id = id; this.x = x; this.y = y; this.angle = angle;
        this.team = team; this.isLocal = isLocal; this.isAI = isAI; this.ownerId = ownerId;
        this.velX=0; this.velY=0; this.baseAcceleration=0.3; this.baseMaxSpeed=5.0;
        this.baseRotationSpeed=3.8; 
        this.baseSideFrictionFactor=0.05;
        this.boostPower=1.8; this.boost=100; 
        this.width=50; this.height=25;
        this.color=team==='left'?'#0066cc':'#cc0000'; this.boosting=false;
        this.role='attacker'; this.isFriendlyAI=(team==='left'); this.aiThrottle=0;
        this.aiStuckState='none'; this.aiStuckStateTimer=0; this.stuckThresholdDist=150;
        this.difficulty=3;
    }
    update(dt) {
        if (this.ownerId === window.netState.user.uid) {
            let throttle = 0;
            if (this.isAI) { this.handleAI(dt, ball, cars); throttle = this.aiThrottle; } 
            else {
                if (keys['KeyW'] || keys['ArrowUp']) throttle = 1;
                else if (keys['KeyS'] || keys['ArrowDown']) throttle = -1;
                if (keys['KeyA'] || keys['ArrowLeft']) this.angle = (this.angle + this.baseRotationSpeed) % 360;
                if (keys['KeyD'] || keys['ArrowRight']) this.angle = (this.angle - this.baseRotationSpeed) % 360;
                const shift = keys['ShiftLeft'] || keys['ShiftRight'];
                this.boosting = !!(shift && this.boost > 0);
            }
            let rad = Math.PI * this.angle / 180;
            let fVel = this.velX*Math.cos(rad) - this.velY*Math.sin(rad);
            let sVel = this.velX*Math.sin(rad) + this.velY*Math.cos(rad);
            if (throttle !== 0) fVel += throttle * this.baseAcceleration;
            if (this.boosting) { fVel += this.baseAcceleration * this.boostPower * (throttle || 1); this.boost = Math.max(0, this.boost - 1.0); }
            fVel *= 0.96; sVel *= (1 - this.baseSideFrictionFactor);
            this.velX = fVel * Math.cos(rad) + sVel * Math.sin(rad);
            this.velY = -fVel * Math.sin(rad) + sVel * Math.cos(rad);
            let speed = Math.hypot(this.velX, this.velY);
            let max = this.baseMaxSpeed * (this.boosting ? this.boostPower : 1);
            if (speed > max) { let scale = max/speed; this.velX*=scale; this.velY*=scale; }
            this.x += this.velX * dt * 60; this.y += this.velY * dt * 60;

            let mw = this.width/2, mh = this.height/2;
            if (this.x < mw) { this.x = mw; this.velX *= -0.5; }
            if (this.x > FIELD_CONSTANTS.CANVAS_WIDTH - mw) { this.x = FIELD_CONSTANTS.CANVAS_WIDTH - mw; this.velX *= -0.5; }
            if (this.y < mh) { this.y = mh; this.velY *= -0.5; }
            if (this.y > FIELD_CONSTANTS.CANVAS_HEIGHT - mh) { this.y = FIELD_CONSTANTS.CANVAS_HEIGHT - mh; this.velY *= -0.5; }

            boostPads.forEach(pad => {
                if (pad.active && Math.hypot(this.x-pad.x, this.y-pad.y) < this.width/2 + pad.radius) {
                    this.boost = Math.min(100, this.boost + 20);
                    // Host handles state logic, Client just predicts visual removal locally if they hit it
                    // but doesn't set active=false for everyone. The Host update loop will confirm it.
                    if (window.netState.isHost) {
                        pad.active = false; pad.cooldown = 5.0;
                    } else {
                        // Visual prediction
                        pad.active = false; 
                    }
                }
            });
        } else {
            const data = remoteEntities[this.id];
            if (data) {
                this.x += (data.x - this.x) * 0.3; 
                this.y += (data.y - this.y) * 0.3; 
                let d = data.angle - this.angle;
                while (d < -180) d += 360; while (d > 180) d -= 360;
                this.angle += d * 0.3; 
                this.boost = data.boost || 100; this.boosting = data.boosting || false;
            }
        }
    }
    handleAI(dt, ball, allCars) {
        if (!ball) return;
        this.aiThrottle = 0;
        if (this.aiStuckState !== 'none') { this.runStuckRoutine(dt, ball); this.aiThrottle = this.throttleDirection; return; }
        let thresh = this.stuckThresholdDist;
        const inDanger = (this.x < thresh || this.x > FIELD_CONSTANTS.CANVAS_WIDTH - thresh || this.y < thresh || this.y > FIELD_CONSTANTS.CANVAS_HEIGHT - thresh);
        if (inDanger && Math.hypot(this.velX, this.velY) < 2.0) {
             this.stuckInCornerTimer += dt;
             if (this.stuckInCornerTimer > 1.5) { this.aiStuckState = 'reversing'; this.aiStuckStateTimer = 0.4; return; }
        } else { this.stuckInCornerTimer = 0; }
        let teammates = allCars.filter(c => c.team === this.team);
        teammates.sort((a, b) => Math.hypot(a.x - ball.x, a.y - ball.y) - Math.hypot(b.x - ball.x, b.y - ball.y));
        let amIClosest = (teammates[0] === this);
        let tx, ty;
        if (amIClosest) { tx = ball.x; ty = ball.y; } 
        else {
            if (this.role === 'attacker') { tx = FIELD_CONSTANTS.CANVAS_WIDTH/2; ty = ball.y > FIELD_CONSTANTS.CANVAS_HEIGHT/2 ? FIELD_CONSTANTS.CANVAS_HEIGHT*0.3 : FIELD_CONSTANTS.CANVAS_HEIGHT*0.7; }
            else if (this.role === 'mid') { tx = (ball.x + (this.team==='right'?FIELD_CONSTANTS.CANVAS_WIDTH:0))/2; ty = (ball.y + FIELD_CONSTANTS.CANVAS_HEIGHT/2)/2; }
            else { tx = ball.x; ty = ball.y; }
        }
        if (this.role === 'defender') {
            let gx = this.isFriendlyAI ? FIELD_CONSTANTS.BALL_RADIUS*3 : FIELD_CONSTANTS.CANVAS_WIDTH - FIELD_CONSTANTS.BALL_RADIUS*3;
            if (!amIClosest) { tx = gx; ty = Math.max(FIELD_CONSTANTS.CANVAS_HEIGHT/2-FIELD_CONSTANTS.GOAL_HEIGHT/2+20, Math.min(ball.y, FIELD_CONSTANTS.CANVAS_HEIGHT/2+FIELD_CONSTANTS.GOAL_HEIGHT/2-20)); }
            else { if(Math.abs(ball.x - gx) < 400) { tx = ball.x; ty = ball.y; } else { tx = gx; ty = Math.max(FIELD_CONSTANTS.CANVAS_HEIGHT/2-FIELD_CONSTANTS.GOAL_HEIGHT/2+20, Math.min(ball.y, FIELD_CONSTANTS.CANVAS_HEIGHT/2+FIELD_CONSTANTS.GOAL_HEIGHT/2-20)); } }
        }
        const dx = tx - this.x, dy = ty - this.y;
        const targetRad = Math.atan2(-dy, dx);
        let targetAngle = (targetRad * 180 / Math.PI + 360) % 360;
        let diff = targetAngle - this.angle;
        if (diff > 180) diff -= 360; if (diff < -180) diff += 360;
        if (diff > this.baseRotationSpeed) this.angle = (this.angle + this.baseRotationSpeed) % 360;
        else if (diff < -this.baseRotationSpeed) this.angle = (this.angle - this.baseRotationSpeed) % 360;
        else this.angle = targetAngle;
        this.throttleDirection = 0;
        if (Math.abs(diff) < 32) {
            this.throttleDirection = 1;
            let rad = Math.PI * this.angle / 180;
            this.velX += Math.cos(rad) * this.baseAcceleration; this.velY -= Math.sin(rad) * this.baseAcceleration;
        }
        this.aiThrottle = this.throttleDirection;
        let dist = Math.hypot(dx, dy);
        this.boosting = (this.difficulty > 5 && Math.abs(diff) < 10 && dist > 150 && this.boost > 20) || (this.role === 'defender' && dist > 300);
    }
    runStuckRoutine(dt, ball) {
        this.aiStuckStateTimer -= dt;
        if (this.aiStuckState === 'reversing') { this.throttleDirection = -1; if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'wall_seek'; this.aiStuckStateTimer = 0.5; } }
        else if (this.aiStuckState === 'wall_seek') { this.throttleDirection = 1; if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'turn_ball'; this.aiStuckStateTimer = 0.4; } }
        else if (this.aiStuckState === 'turn_ball') { if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'hit_ball'; this.aiStuckStateTimer = 0.4; } }
        else if (this.aiStuckState === 'hit_ball') { this.throttleDirection = 1; if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'reversing_small'; this.aiStuckStateTimer = 0.3; } }
        else if (this.aiStuckState === 'reversing_small') { this.throttleDirection = -1; if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'none'; this.stuckInCornerTimer = 0; } }
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); 
        ctx.save();
        ctx.rotate(-this.angle * Math.PI / 180);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.roundRect(-25, -13, 50, 26, 4); ctx.fill();
        ctx.fillStyle = '#1f2937'; ctx.beginPath(); ctx.roundRect(-5, -10, 20, 20, 2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(-25, -3, 50, 6);
        ctx.fillStyle = this.color; ctx.beginPath(); ctx.roundRect(-28, -15, 6, 30, 2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.fillRect(-20, -15, 12, 4); ctx.fillRect(10, -15, 12, 4); ctx.fillRect(-20, 11, 12, 4); ctx.fillRect(10, 11, 12, 4); 
        if (this.boosting) {
            ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.moveTo(-28, 0); ctx.lineTo(-50 - Math.random()*10, -8); ctx.lineTo(-50 - Math.random()*10, 8); ctx.fill();
            ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.moveTo(-28, 0); ctx.lineTo(-40 - Math.random()*5, -4); ctx.lineTo(-40 - Math.random()*5, 4); ctx.fill();
        }
        ctx.restore(); 
        ctx.fillStyle = '#374151'; 
        ctx.fillRect(-20, -35, 40, 6); 
        ctx.fillStyle = this.boost > 50 ? '#fbbf24' : (this.boost > 20 ? '#f59e0b' : '#ef4444');
        ctx.fillRect(-19, -34, 38 * (this.boost/100), 4); 

        ctx.fillStyle = 'white'; ctx.font = '10px Inter'; ctx.textAlign = 'center';
        const ownerName = window.netState.playerMap[this.ownerId]?.username;
        // --- FIX: Always Uppercase Name ---
        ctx.fillText(this.isAI ? `AI` : (ownerName || 'P').toUpperCase(), 0, -40);

        ctx.restore(); 
    }
}

class Ball {
    constructor(x, y) { 
        this.x=x; this.y=y; this.velX=0; this.velY=0; this.radius=FIELD_CONSTANTS.BALL_RADIUS; 
        this.val = 1; 
    }
    
    update(dt) {
        // --- ALWAYS RUN LOCAL PHYSICS ---
        this.x += this.velX*dt*60; this.y += this.velY*dt*60;
        this.velX *= 0.98; this.velY *= 0.98;
        
        const goalHeight = FIELD_CONSTANTS.GOAL_HEIGHT;
        const goalTop = FIELD_CONSTANTS.CANVAS_HEIGHT / 2 - goalHeight / 2;
        const goalBottom = FIELD_CONSTANTS.CANVAS_HEIGHT / 2 + goalHeight / 2;

        if (this.y<this.radius) { this.y=this.radius; this.velY*=-0.8; }
        if (this.y>FIELD_CONSTANTS.CANVAS_HEIGHT-this.radius) { this.y=FIELD_CONSTANTS.CANVAS_HEIGHT-this.radius; this.velY*=-0.8; }

        const inGoalY = this.y >= goalTop && this.y <= goalBottom;

        if (this.x<this.radius && !inGoalY) { this.x=this.radius; this.velX*=-0.8; }
        if (this.x>FIELD_CONSTANTS.CANVAS_WIDTH-this.radius && !inGoalY) { this.x=FIELD_CONSTANTS.CANVAS_WIDTH-this.radius; this.velX*=-0.8; }
        
        // --- CLIENT SIDE RECONCILIATION (FIXED LAG) ---
        if (!window.netState.isHost) {
            const d = remoteEntities['ball'];
            if(d) { 
                const timeSinceHit = Date.now() - lastBallHitTime;
                const dist = Math.hypot(d.x - this.x, d.y - this.y);

                // TRUST WINDOW IMPROVED:
                // If we hit the ball recently (<800ms), ignore server to allow local physics to play out smoothly.
                // Unless deviation is massive (>400px), which means we were totally wrong.
                if (timeSinceHit < 800 && dist < 400) {
                    // Trust local physics completely
                } else {
                    if (dist > 300) { 
                        // Hard snap if too far
                        this.x = d.x; this.y = d.y; 
                    } else {
                        // Smoother lerp (reduced from 0.3 to 0.15 to prevent jitter)
                        this.x += (d.x - this.x) * 0.15; 
                        this.y += (d.y - this.y) * 0.15; 
                    }
                }
                this.val = d.val || 1;
            }
        }
    }
    
    draw() {
        if(this.val === 3) ctx.fillStyle = '#ffd700'; 
        else if(this.val === 2) ctx.fillStyle = '#a855f7'; 
        else ctx.fillStyle = '#00fff4'; 

        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.beginPath(); ctx.arc(this.x-5, this.y-5, 6, 0, Math.PI*2); ctx.fill();
        
        if(this.val > 1) {
            ctx.fillStyle = '#000'; ctx.font = 'bold 14px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(`x${this.val}`, this.x, this.y);
        }
    }
}

window.initGame = (roomData) => {
    gameState = 'playing';
    document.getElementById('app').classList.add('in-game');
    switchScreen('screen-game');
    roomSettings = roomData;
    cars = []; boostPads = []; score = {left:0, right:0};
    gameTimer = roomData.duration; 
    gameTimerFlashed = false;
    lastBallHitTime = 0;
    
    const padLocs = [{x: 200, y: 200}, {x: 800, y: 200}, {x: 200, y: 400}, {x: 800, y: 400}, {x: 500, y: 100}, {x: 500, y: 500}];
    padLocs.forEach(p => boostPads.push(new BoostPad(p.x, p.y)));

    const count = roomData.mode === '2v2' ? 4 : (roomData.mode === '3v3' ? 6 : 2);
    const players = Object.values(window.netState.playerMap);
    const connIds = window.netState.connectedPlayersList;
    let aiCars = [];

    for (let i = 0; i < count; i++) {
        const p = players.find(pl => pl.slotIndex === i);
        const isRed = i % 2 !== 0;
        const startX = isRed ? 900 : 100;
        const startY = 300 + (Math.floor(i/2) * 80 * (i%4==0?1:-1));
        const angle = isRed ? 180 : 0;
        const id = p ? p.id : `ai_${i}`;
        const team = isRed ? 'right' : 'left';
        let ownerId = p ? p.id : connIds[i % connIds.length];
        const isMe = ownerId === window.netState.user.uid;
        const newCar = new Car(id, startX, startY, angle, team, isMe && !!p, !p, ownerId);
        newCar.resetPos = {x: startX, y: startY, angle: angle};
        cars.push(newCar);
        if(isMe && !!p) localCar = newCar;
        if(!p) aiCars.push(newCar);
    }
    aiCars.sort((a, b) => a.id.localeCompare(b.id)).forEach((ai, idx) => {
        const roles = ["attacker", "defender", "mid", "attacker", "mid", "defender"];
        ai.role = roles[idx % roles.length];
    });
    ball = new Ball(500, 300);
    lastTime = Date.now();
    loop();
};

window.handleGameStateUpdate = (data) => {
    if (data.ball) {
        remoteEntities['ball'] = data.ball;
        if(ball) ball.val = data.ball.val || 1;
    }
    if (data.scores) { 
        document.getElementById('score-left').innerText = data.scores.left; 
        document.getElementById('score-right').innerText = data.scores.right; 
        score = data.scores; 
    }
    // --- FIX: Sync Pads from Server ---
    if (data.pads && boostPads.length > 0) {
        data.pads.forEach((active, i) => {
            if (boostPads[i]) boostPads[i].active = !!active;
        });
    }
    
    if (data.winner) {
        if (gameState === 'finished') return; 

        const myUid = window.netState.user.uid;
        const me = window.netState.playerMap[myUid];
        const myTeam = me ? me.team : 'spectator';
        const title = document.getElementById('result-title');
        
        document.getElementById('end-score-blue').innerText = score.left;
        document.getElementById('end-score-red').innerText = score.right;
        
        if (data.winner === 'draw') {
             title.innerText = "DRAW";
             title.className = "text-8xl font-black italic tracking-tighter mb-2 text-white";
        } else if (myTeam === 'spectator') {
             title.innerText = data.winner.toUpperCase() + " WINS";
             title.className = "text-8xl font-black italic tracking-tighter mb-2 text-white";
        } else {
             const won = (data.winner === myTeam);
             title.innerText = won ? "YOU WIN" : "YOU LOSE";
             const colorClass = myTeam === 'left' ? 'text-blue-500' : 'text-red-500';
             title.className = `text-8xl font-black italic tracking-tighter mb-2 ${colorClass}`;
        }
        
        gameState = 'finished';
        switchScreen('screen-result');
    }

    if (data.timer !== undefined) { 
        const tBox = document.getElementById('game-timer');
        if (roomSettings.type === 'points') {
            tBox.classList.add('points');
            tBox.classList.remove('countdown');
        } else {
            tBox.classList.remove('points');
            if (data.timer <= 10 && data.timer > 0) {
                tBox.classList.add('countdown');
                tBox.innerText = Math.ceil(data.timer); 
            } else {
                tBox.classList.remove('countdown');
                const m = Math.floor(data.timer/60), s = Math.floor(data.timer%60); 
                tBox.innerText = `${m}:${s<10?'0'+s:s}`;
            }
            const duration = roomSettings.duration || 120;
            const isHalf = Math.abs(data.timer - duration/2) < 0.5;
            const is30 = Math.abs(data.timer - 30) < 0.5;
            if (isHalf || is30) {
                if (!tBox.dataset.flashed) {
                    tBox.classList.add('glow-red');
                    tBox.dataset.flashed = "true";
                    setTimeout(() => tBox.classList.remove('glow-red'), 1000);
                }
            } else {
                tBox.dataset.flashed = "";
            }
        }
    }
    if (data.paused !== undefined) { 
        const m = document.getElementById('modal-pause'); 
        if(data.paused) m.style.display = 'flex'; 
        else m.style.display = 'none'; 
    }
};
window.handleRemoteEntityUpdate = (data) => { Object.keys(data).forEach(k => remoteEntities[k] = data[k]); };

async function loop() {
    requestAnimationFrame(loop);
    if (gameState !== 'playing') return;

    const now = Date.now(), dt = (now - lastTime) / 1000;
    lastTime = now;
    
    drawField(ctx, canvas);

    const isPaused = document.getElementById('modal-pause').style.display === 'flex';

    if (!isPaused) {
        if (window.netState.isHost && roomSettings.type === 'timed') {
            gameTimer -= dt;
            if (gameTimer <= 0) {
                gameTimer = 0;
                let winner = 'draw';
                if (score.left > score.right) winner = 'left';
                if (score.right > score.left) winner = 'right';
                
                window.handleGameStateUpdate({ winner: winner, scores: score });
                gameState = 'finished'; 
                
                await window.sendGameUpdate(null, null, { scores: score, timer: 0, winner: winner });
                if (window.updateDoc) {
                    await window.updateDoc(doc(window.netState.db, 'artifacts', typeof __app_id !== 'undefined' ? __app_id : 'default-app', 'public', 'data', 'rooms', window.netState.currentRoomId), { status: 'finished' });
                }
                return; 
            }
        }

        boostPads.forEach(p => { 
            // Only Host updates cooldown timers to ensure sync
            if (window.netState.isHost) p.update(dt); 
            p.draw(); 
        });
        
        ball.update(dt);
        
        const myUpdateData = {};
        for (let i = 0; i < cars.length; i++) {
            for (let j = i + 1; j < cars.length; j++) {
                const c1 = cars[i], c2 = cars[j];
                const dist = Math.hypot(c1.x - c2.x, c1.y - c2.y);
                const minDist = 45; 
                if (dist < minDist) {
                    const angle = Math.atan2(c1.y - c2.y, c1.x - c2.x);
                    const overlap = minDist - dist;
                    const pushX = Math.cos(angle) * overlap * 0.5;
                    const pushY = Math.sin(angle) * overlap * 0.5;

                    if (c1.ownerId === window.netState.user.uid) { 
                        c1.x += pushX; c1.y += pushY; 
                        c1.velX += Math.cos(angle) * 2; 
                        c1.velY += Math.sin(angle) * 2;
                    }
                    if (c2.ownerId === window.netState.user.uid) { 
                        c2.x -= pushX; c2.y -= pushY; 
                        c2.velX -= Math.cos(angle) * 2; 
                        c2.velY -= Math.sin(angle) * 2;
                    }
                }
            }
        }

        cars.forEach(c => {
            c.update(dt); c.draw();
            if (c.ownerId === window.netState.user.uid) {
                myUpdateData[c.id] = { x: Math.round(c.x), y: Math.round(c.y), angle: Math.round(c.angle), boost: Math.round(c.boost), boosting: !!c.boosting };
                const dx = ball.x - c.x, dy = ball.y - c.y, dist = Math.hypot(dx, dy);
                if (dist < FIELD_CONSTANTS.BALL_RADIUS + 50/2) {
                    const angle = Math.atan2(dy, dx), overlap = (FIELD_CONSTANTS.BALL_RADIUS + 50/2) - dist;
                    c.x -= Math.cos(angle) * overlap; c.y -= Math.sin(angle) * overlap;
                    c.velX -= Math.cos(angle) * 5; c.velY -= Math.sin(angle) * 5;
                    
                    // --- FIX: Client-side Ball Hit ---
                    // Apply velocity immediately to local ball
                    ball.velX += Math.cos(angle) * 15; 
                    ball.velY += Math.sin(angle) * 15;
                    
                    // Record timestamp so we ignore server updates for a short while
                    lastBallHitTime = Date.now();
                }
            }
        });
        ball.draw();
        
        if (localCar) {
            document.getElementById('boost-fill').style.width = localCar.boost + '%';
            document.getElementById('boost-bar-container').style.display = 'block';
        } else { document.getElementById('boost-bar-container').style.display = 'none'; }

        if (Object.keys(myUpdateData).length > 0 || window.netState.isHost) {
            let ballData = null;
            let gameData = null;
            
            if (window.netState.isHost) {
                ballData = { x: Math.round(ball.x), y: Math.round(ball.y), val: ball.val };
                // --- FIX: Send Pad States ---
                const padStates = boostPads.map(p => p.active ? 1 : 0);
                gameData = { scores: score, timer: gameTimer, paused: isPaused, pads: padStates };
            }
            
            // Only send network request if we have car data OR we are host sending game state
            if (Object.keys(myUpdateData).length > 0 || window.netState.isHost) {
                window.sendGameUpdate(Object.keys(myUpdateData).length ? myUpdateData : null, ballData, gameData);
            }
        }
        
        // HOST LOGIC: Scoring
        if (window.netState.isHost) {
            const scoringTeam = checkGoal(ball, canvas);
            if (scoringTeam) {
                const points = ball.val; 
                if (scoringTeam === 'left') score.left += points;
                if (scoringTeam === 'right') score.right += points;
                
                ball.x = 500; 
                ball.y = 150 + Math.random() * 300;
                ball.velX = 0; ball.velY = 0; 

                cars.forEach(c => {
                    if(c.resetPos) { c.x = c.resetPos.x; c.y = c.resetPos.y; c.angle = c.resetPos.angle; c.velX = 0; c.velY = 0; c.boost = 100; }
                });

                if (roomSettings.type === 'points' && (score.left >= roomSettings.scoreTarget || score.right >= roomSettings.scoreTarget)) {
                    let winner = score.left >= roomSettings.scoreTarget ? 'left' : 'right';
                    
                    window.handleGameStateUpdate({ winner: winner, scores: score });
                    gameState = 'finished'; 
                    
                    await window.sendGameUpdate({}, {x:ball.x, y:ball.y, val:ball.val}, { scores: score, timer: 0, winner: winner }); 
                    if (window.updateDoc) {
                         await window.updateDoc(doc(window.netState.db, 'artifacts', typeof __app_id !== 'undefined' ? __app_id : 'default-app', 'public', 'data', 'rooms', window.netState.currentRoomId), { status: 'finished' });
                    }
                    return; 
                }

                const rand = Math.random();
                if (rand < 0.05) ball.val = 3; 
                else if (rand < 0.15) ball.val = 2; 
                else ball.val = 1;

                window.sendGameUpdate({}, {x:ball.x, y:ball.y, val:ball.val}, { scores: score, timer: gameTimer }); 
            }
        }
    }
}

window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);
</script>
</body>
</html>
