<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Online Car Game (P2P)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PeerJS SDK for WebRTC Networking -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>
        // --- NETWORKING LOGIC (P2P) ---
        
        // Global Network State
        window.netState = {
            peer: null,             // My Peer Instance
            myId: null,             // My Peer ID
            hostConn: null,         // Connection to Host (if I am guest)
            clientConns: [],        // List of connections (if I am host)
            isHost: false,
            user: { username: "Player", uid: null },
            roomId: null,
            roomSettings: {},
            players: [],            // List of all players (Synced from Host)
            lastUpdateSent: 0
        };

        // Flag to prevent browser warning when we exit intentionally
        window.isIntentionalExit = false;

        // Initialize Peer (Called when creating or joining)
        async function initPeer(customId = null) {
            return new Promise((resolve, reject) => {
                const opts = { debug: 1 }; 
                if (window.netState.peer) window.netState.peer.destroy();

                window.netState.peer = customId ? new Peer(customId, opts) : new Peer(opts);

                window.netState.peer.on('open', (id) => {
                    window.netState.myId = id;
                    window.netState.user.uid = id; 
                    updateStatus("Online", "text-green-400");
                    resolve(id);
                });

                window.netState.peer.on('error', (err) => {
                    console.error("Peer Error:", err);
                    if (err.type === 'unavailable-id') {
                        window.finalizeCreateRoom().catch(e => alert("Could not generate room ID. Try again."));
                        reject("ID Taken");
                    } else {
                        updateStatus("Error", "text-red-500");
                        reject(err);
                    }
                });

                window.netState.peer.on('connection', (conn) => {
                    handleIncomingConnection(conn);
                });
            });
        }

        // --- HOST LOGIC ---
        function handleIncomingConnection(conn) {
            conn.on('open', () => {
                window.netState.clientConns.push(conn);
                conn.on('data', (data) => handlePacket(data, conn.peer));
                conn.on('close', () => handlePlayerDisconnect(conn.peer));
                
                // Send current full state
                sendToClient(conn, { 
                    type: 'LOBBY_STATE', 
                    payload: { 
                        settings: window.hostConfig, 
                        players: window.netState.players,
                        roomId: window.netState.roomId 
                    } 
                });
            });
        }

        function broadcastToClients(type, payload) {
            if (!window.netState.isHost) return;
            const packet = { type, payload };
            window.netState.clientConns.forEach(conn => {
                if(conn.open) conn.send(packet);
            });
        }

        function handlePlayerDisconnect(peerId) {
            if (!window.netState.isHost) return;
            window.netState.clientConns = window.netState.clientConns.filter(c => c.peer !== peerId);
            window.netState.players = window.netState.players.filter(p => p.userId !== peerId);
            delete remoteEntities[`${window.netState.roomId}_${peerId}`];
            
            broadcastToClients('LOBBY_STATE', {
                settings: window.hostConfig,
                players: window.netState.players,
                roomId: window.netState.roomId
            });
            window.renderSlots(window.netState.players);
        }

        // --- CLIENT LOGIC ---
        function connectToHost(hostId) {
            const conn = window.netState.peer.connect(hostId, { reliable: true });
            conn.on('open', () => {
                window.netState.hostConn = conn;
                window.netState.roomId = hostId;
                updateStatus("Connected to Host", "text-blue-400");
                sendToHost('JOIN_REQUEST', { username: window.netState.user.username, userId: window.netState.myId });
                document.getElementById('lobby-code').innerText = hostId;
                window.switchScreen('screen-lobby');
            });
            conn.on('data', (data) => handlePacket(data, 'HOST'));
            
            // --- CHANGED: Show Modal instead of Alert ---
            conn.on('close', () => { 
                document.getElementById('modal-disconnected').style.display = 'flex';
            });
            
            conn.on('error', (err) => console.error("Conn Error", err));
        }

        function sendToHost(type, payload) {
            if (window.netState.hostConn && window.netState.hostConn.open) {
                window.netState.hostConn.send({ type, payload });
            }
        }

        function sendToClient(conn, packet) {
            if(conn && conn.open) conn.send(packet);
        }

        // --- SHARED PACKET HANDLER ---
        function handlePacket(packet, senderId) {
            const { type, payload } = packet;

            // --- CONNECTION / LOBBY ---
            if (type === 'JOIN_REQUEST') {
                if (!window.netState.isHost) return;
                const newPlayer = {
                    roomId: window.netState.roomId,
                    userId: payload.userId,
                    username: payload.username,
                    isHost: false, isReady: false, slotIndex: -1, team: 'spectator'
                };
                const idx = window.netState.players.findIndex(p => p.userId === payload.userId);
                if (idx === -1) window.netState.players.push(newPlayer);
                else window.netState.players[idx] = newPlayer; 

                broadcastToClients('LOBBY_STATE', { settings: window.hostConfig, players: window.netState.players, roomId: window.netState.roomId });
                window.renderSlots(window.netState.players);
            }

            else if (type === 'LOBBY_STATE') {
                window.netState.players = payload.players;
                window.hostConfig = payload.settings; 
                window.updateLobbyUI(payload.settings);
                window.renderSlots(payload.players);
                if (payload.settings.status === 'playing' && window.gameState !== 'playing') {
                     window.initGame(payload.settings);
                }
            }
            
            else if (type === 'SLOT_UPDATE') {
                if (!window.netState.isHost) return;
                const p = window.netState.players.find(p => p.userId === senderId);
                if (p) {
                    if (payload.action === 'claim') { p.slotIndex = payload.index; p.team = payload.team; p.isReady = false; } 
                    else if (payload.action === 'ready') { p.isReady = payload.state; }
                    broadcastToClients('LOBBY_STATE', { settings: window.hostConfig, players: window.netState.players, roomId: window.netState.roomId });
                    window.renderSlots(window.netState.players);
                }
            }

            // --- GAMEPLAY SYNC ---
            else if (type === 'GAME_UPDATE') {
                if (window.netState.isHost) return; 
                window.handleGameStateUpdate(payload);
            }

            else if (type === 'ENTITY_UPDATE') {
                if (window.netState.isHost) {
                    // Host receives updates from a client about their car
                    Object.keys(payload).forEach(key => { remoteEntities[key] = payload[key]; });
                    // Relay to others
                    window.netState.clientConns.forEach(conn => {
                        if (conn.peer !== senderId && conn.open) conn.send({ type: 'ENTITY_UPDATE', payload: payload });
                    });
                } else {
                    window.handleRemoteEntityUpdate(payload);
                }
            }
            
            else if (type === 'BALL_HIT') {
                if (!window.netState.isHost) return;
                // Host receives new velocity data from a client who hit the ball
                if (ball) {
                    ball.x = payload.x;
                    ball.y = payload.y;
                    ball.velX = payload.velX;
                    ball.velY = payload.velY;
                }
            }

            else if (type === 'BOOST_TAKEN') {
                if (!window.netState.isHost) return;
                // Client says "I took boost pad #X"
                const idx = payload.index;
                if (boostPads[idx]) {
                    boostPads[idx].active = false;
                    boostPads[idx].cooldown = 5.0;
                }
            }
        }

        function updateStatus(msg, classStr) {
            const container = document.getElementById('status-container');
            const el = document.getElementById('connection-status');
            if (!msg) {
                container.style.display = 'none';
            } else {
                container.style.display = 'block';
                el.textContent = "‚óè " + msg;
                el.className = classStr + " font-bold text-sm";
            }
        }

        // --- CHANGED: Smart Tab Warning ---
        window.addEventListener('beforeunload', function (e) {
            if (window.netState.roomId && !window.isIntentionalExit) { 
                e.preventDefault(); 
                e.returnValue = ''; 
            }
        });

    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body { 
            background: #111827; color: white; font-family: 'Inter', sans-serif; 
            overflow: hidden; margin: 0; display: flex; align-items: center; justify-content: center; height: 100vh;
        }
        #app { 
            width: 95vw; max-width: 1100px; 
            height: 90vh;
            position: relative; background: #1f2937; border-radius: 16px; 
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); overflow: hidden; display: flex; flex-direction: column;
            transition: all 0.5s ease; 
        }
        
        #app.in-game {
            max-width: 1400px;
            width: 98vw;
            height: auto;
            aspect-ratio: 16/9;
            max-height: 95vh;
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: -webkit-optimize-contrast; }
        
        .screen { position: absolute; inset: 0; display: none; flex-direction: column; align-items: center; justify-content: center; background: #1f2937; z-index: 10; }
        .screen.active { display: flex; }
        
        .btn { padding: 14px 28px; border-radius: 12px; font-weight: 900; text-transform: uppercase; transition: 0.2s; cursor: pointer; border: none; font-size: 1.1rem; width: 200px; }
        .btn-primary { background: #fbbf24; color: #1f2937; }
        .btn-primary:hover { background: #f59e0b; transform: translateY(-2px); }
        .btn-outline { border: 3px solid #4b5563; color: #d1d5db; background: transparent; }
        .btn-outline:hover { border-color: #fbbf24; color: #fbbf24; }
        .btn-danger { background: #ef4444; color: white; }
        
        .inp-lg { 
            background: #374151; border: 3px solid #4b5563; padding: 16px; border-radius: 12px; 
            color: white; text-align: center; font-size: 1.5rem; font-weight: bold; width: 100%; max-width: 400px;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .inp-lg:focus { outline: none; border-color: #fbbf24; }

        .slot { 
            width: 100%; height: 80px; border: 2px dashed #4b5563; border-radius: 8px; 
            display: flex; align-items: center; justify-content: space-between; padding: 0 20px;
            cursor: pointer; transition: 0.2s; position: relative; background: rgba(0,0,0,0.2);
        }
        .slot:hover { border-color: #9ca3af; background: rgba(255,255,255,0.05); }
        .slot.filled { border-style: solid; cursor: default; }
        .slot.filled.blue { border-color: #3b82f6; background: linear-gradient(90deg, rgba(30,58,138,0.8), transparent); }
        .slot.filled.red { border-color: #ef4444; background: linear-gradient(90deg, rgba(127,29,29,0.8), transparent); }
        .slot.ai { border: 1px solid rgba(255,255,255,0.1); opacity: 0.5; }
        
        .mode-card {
            width: 120px; height: 120px; background: #374151; border: 3px solid #4b5563;
            display: flex; align-items: center; justify-content: center; border-radius: 16px;
            font-size: 1.5rem; font-weight: 900; cursor: pointer; transition: 0.2s; text-align: center; flex-direction: column; gap: 5px;
        }
        .mode-card:hover { border-color: #fbbf24; color: #fbbf24; transform: scale(1.05); }
        .mode-card span { font-size: 0.8rem; font-weight: normal; opacity: 0.7; }

        #bottom-hud {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 80px;
            background: linear-gradient(to top, #111827, transparent);
            display: flex; align-items: flex-end; justify-content: space-between;
            padding: 10px 30px; pointer-events: none; z-index: 20;
        }
        .score-box { font-size: 2.5rem; font-weight: 900; text-shadow: 0 2px 8px rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; line-height: 1; }
        
        .timer-box { font-family: monospace; font-size: 2rem; font-weight: bold; color: white; text-shadow: 0 2px 4px black; margin-bottom: 10px; transition: all 0.3s ease; }
        .timer-box.hidden-mode { display: none !important; } /* Explicitly hidden */
        .timer-box.glow-red { color: #ef4444; text-shadow: 0 0 20px #ef4444; transform: scale(1.3); }
        /* FIX: Bigger countdown with light red border */
        .timer-box.countdown { 
            color: #ef4444; 
            font-size: 8rem; /* Bigger */
            text-shadow: 4px 4px 0 #000; 
            -webkit-text-stroke: 3px #fca5a5; /* Light red border */
        }
        
        .boost-container {
            width: 200px; height: 20px; background: #374151; border: 2px solid #4b5563;
            border-radius: 10px; overflow: hidden; margin-bottom: 15px; position: relative;
        }
        .boost-fill { height: 100%; background: linear-gradient(90deg, #f59e0b, #fbbf24); width: 100%; transition: width 0.1s linear; }
        .boost-text { position: absolute; top: 0; left: 0; width: 100%; text-align: center; font-size: 0.7rem; font-weight: bold; color: black; line-height: 18px; }
        
        #goal-flash { display: none !important; }
    </style>
</head>
<body>

<div id="app">
    <!-- Status Bar -->
    <div class="absolute top-4 left-4 z-50 flex gap-4 items-center">
        <div id="status-container" class="bg-gray-900/80 px-3 py-1 rounded-full backdrop-blur-sm border border-gray-700" style="display: none;">
            <span id="connection-status" class="font-mono tracking-wider text-xs text-yellow-500"></span>
        </div>
    </div>

    <!-- SCREEN: START -->
    <div id="screen-start" class="screen active text-center">
        <h1 class="text-7xl font-black text-yellow-400 mb-2 tracking-tighter italic" style="text-shadow: 4px 4px 0 #000;">ONLINE <span class="text-white">CAR GAME</span></h1>
        <p class="text-gray-400 mb-10 tracking-widest text-sm font-bold uppercase">MADE BY ERIC</p>
        
        <div id="login-container" class="flex flex-col items-center w-full transition-opacity duration-500">
            <div class="mb-2 w-full max-w-[400px] text-left text-gray-500 text-xs font-bold ml-2">NAME</div>
            <input type="text" id="inp-name" class="inp-lg mb-6" placeholder="ENTER NAME" maxlength="12">
            <div id="name-error" class="h-6 text-red-500 font-bold text-sm mb-4 opacity-0 transition-opacity">Name too short (3+ chars)</div>
            
            <div class="flex flex-col gap-4 w-full items-center">
                <button class="btn btn-primary shadow-lg shadow-yellow-500/20" onclick="goToModeSelect()">CREATE ROOM</button>
                <button class="btn btn-outline" onclick="goToJoin()">JOIN ROOM</button>
            </div>
        </div>
    </div>

    <!-- SCREEN: MODE SELECT -->
    <div id="screen-mode" class="screen">
        <h2 class="text-4xl font-black mb-10 italic text-white">SELECT TEAM SIZE</h2>
        <div class="flex gap-6 mb-10">
            <div class="mode-card" onclick="setHostMode('1v1')">1v1 <span>2 Players</span></div>
            <div class="mode-card" onclick="setHostMode('2v2')">2v2 <span>4 Players</span></div>
            <div class="mode-card" onclick="setHostMode('3v3')">3v3 <span>6 Players</span></div>
        </div>
        <button class="btn btn-outline" onclick="switchScreen('screen-start')">BACK</button>
    </div>

    <!-- SCREEN: TYPE SELECT -->
    <div id="screen-type" class="screen">
        <h2 class="text-4xl font-black mb-10 italic text-white">GAME TYPE</h2>
        <div class="flex gap-6 mb-10">
            <div class="mode-card" onclick="setHostType('timed')">TIMED <span>Race against clock</span></div>
            <div class="mode-card" onclick="setHostType('points')">POINTS <span>First to score</span></div>
        </div>
        <button class="btn btn-outline" onclick="switchScreen('screen-mode')">BACK</button>
    </div>

    <!-- SCREEN: LIMIT SELECT -->
    <div id="screen-limit" class="screen">
        <h2 class="text-4xl font-black mb-10 italic text-white" id="limit-title">DURATION</h2>
        <div class="flex flex-wrap gap-6 mb-10 justify-center" id="limit-buttons"></div>
        <button class="btn btn-outline" onclick="switchScreen('screen-type')">BACK</button>
    </div>

    <!-- SCREEN: JOIN INPUT -->
    <div id="screen-join" class="screen">
        <h2 class="text-3xl font-black mb-6">JOIN FREQUENCY</h2>
        <input type="text" id="inp-room-code" class="inp-lg mb-6" placeholder="ROOM CODE">
        <div class="flex gap-4">
            <button class="btn btn-outline" onclick="switchScreen('screen-start')">BACK</button>
            <button class="btn btn-primary" onclick="joinRoomAction()">CONNECT</button>
        </div>
    </div>

    <!-- SCREEN: LOBBY -->
    <div id="screen-lobby" class="screen">
        <div class="absolute top-4 left-4 flex gap-2" style="top: 60px;">
            <button class="bg-red-500/20 text-red-400 px-4 py-2 rounded-lg text-xs font-bold hover:bg-red-500/40 border border-red-500/30" onclick="window.leaveRoom()">EXIT LOBBY</button>
        </div>
        
        <div class="text-center mb-4">
            <div class="text-xs text-gray-500 font-bold tracking-widest mb-1">ROOM CODE (SHARE THIS)</div>
            <div id="lobby-code" class="text-6xl font-mono font-black text-white select-all tracking-widest" style="text-shadow: 0 0 20px rgba(255,255,255,0.2);">...</div>
        </div>

        <div id="lobby-info" class="flex gap-4 mb-6">
            <div class="bg-gray-800 px-4 py-2 rounded text-sm font-bold text-gray-400" id="info-mode">MODE: 1v1</div>
            <div class="bg-gray-800 px-4 py-2 rounded text-sm font-bold text-gray-400" id="info-type">TYPE: TIMED</div>
            <div class="bg-gray-800 px-4 py-2 rounded text-sm font-bold text-gray-400" id="info-limit">LIMIT: 2 MIN</div>
        </div>

        <!-- SLOTS -->
        <div class="flex justify-between w-full px-8 mb-8 h-[300px]">
            <div class="slot-col w-1/2 pr-2" id="col-blue">
                <div class="text-blue-400 font-black text-xl italic mb-2 text-center">BLUE TEAM</div>
                <div id="slots-blue" class="flex flex-col gap-3"></div>
            </div>
            <div class="flex flex-col justify-center items-center">
                <div class="h-full w-px bg-gray-700"></div>
                <div class="py-4 text-gray-600 font-black text-2xl italic">VS</div>
                <div class="h-full w-px bg-gray-700"></div>
            </div>
            <div class="slot-col w-1/2 pl-2" id="col-red">
                <div class="text-red-400 font-black text-xl italic mb-2 text-center">RED TEAM</div>
                <div id="slots-red" class="flex flex-col gap-3"></div>
            </div>
        </div>

        <div class="flex flex-col items-center gap-3">
            <button id="btn-lobby-action" class="btn shadow-xl" onclick="lobbyAction()">JOIN A TEAM</button>
            <button id="btn-host-start" class="btn bg-green-600 hover:bg-green-500 text-white hidden shadow-lg shadow-green-500/20" onclick="window.startGame()">START MATCH</button>
            <p id="host-warning" class="text-red-500 text-xs font-bold hidden">YOU MUST JOIN A TEAM TO START</p>
        </div>
    </div>

    <!-- SCREEN: RESULT -->
    <div id="screen-result" class="screen z-50 bg-gray-900">
        <h1 id="result-title" class="text-8xl font-black italic tracking-tighter mb-2" style="text-shadow: 0 10px 30px rgba(0,0,0,0.5);">VICTORY</h1>
        <div class="flex gap-10 mb-10">
            <div class="flex flex-col items-center">
                <div class="text-blue-500 font-bold text-sm mb-1">BLUE</div>
                <div id="end-score-blue" class="text-6xl font-black text-white">0</div>
            </div>
            <div class="flex flex-col items-center justify-center">
                <div class="text-gray-600 text-4xl font-black italic">-</div>
            </div>
            <div class="flex flex-col items-center">
                <div class="text-red-500 font-bold text-sm mb-1">RED</div>
                <div id="end-score-red" class="text-6xl font-black text-white">0</div>
            </div>
        </div>
        <button class="btn btn-primary" onclick="window.leaveRoom()">BACK TO MENU</button>
    </div>

    <!-- SCREEN: GAME -->
    <div id="screen-game" class="screen">
        <div id="goal-flash">
            <h1 class="text-9xl font-black text-yellow-400 italic tracking-tighter" style="text-shadow: 10px 10px 0 rgba(0,0,0,0.5); -webkit-text-stroke: 4px black;">GOAL!</h1>
        </div>

        <button class="absolute top-4 right-4 z-20 bg-red-900/80 hover:bg-red-700 text-white px-4 py-2 rounded-lg text-xs font-bold border border-red-500/50" onclick="tryExitGame()">EXIT</button>
        
        <canvas id="canvas"></canvas>

        <!-- Bottom HUD -->
        <div id="bottom-hud">
            <div class="score-box text-blue-400">
                <div class="text-xs text-blue-500/70 font-bold tracking-wider">BLUE</div>
                <div id="score-left">0</div>
            </div>
            
            <div class="flex flex-col items-center">
                <div id="game-timer" class="timer-box">00:00</div>
                <div id="boost-bar-container" class="boost-container">
                    <div id="boost-fill" class="boost-fill"></div>
                    <div class="boost-text">BOOST</div>
                </div>
            </div>

            <div class="score-box text-red-400">
                <div class="text-xs text-red-500/70 font-bold tracking-wider">RED</div>
                <div id="score-right">0</div>
            </div>
        </div>
        
        <!-- Modals -->
        <div id="modal-pause" class="absolute inset-0 bg-black/80 hidden z-50 flex flex-col items-center justify-center backdrop-blur-sm">
            <h2 class="text-5xl text-white font-black mb-10 italic">GAME PAUSED</h2>
            <button class="btn btn-primary w-64 mb-6" onclick="pauseGame()">RESUME</button>
        </div>

        <div id="modal-exit" class="absolute inset-0 bg-black/90 hidden z-50 flex flex-col items-center justify-center backdrop-blur-sm">
            <h2 class="text-3xl text-white font-bold mb-4">LEAVE GAME?</h2>
            <p class="text-gray-400 mb-8">You will disconnect from the room.</p>
            <div class="flex gap-4">
                <button class="btn btn-danger w-32" onclick="window.leaveRoom()">LEAVE</button>
                <button class="btn btn-outline w-32" onclick="cancelExit()">CANCEL</button>
            </div>
        </div>

        <!-- ADDED: Disconnect Modal (Replaces Alert) -->
        <div id="modal-disconnected" class="absolute inset-0 bg-black/95 hidden z-50 flex flex-col items-center justify-center backdrop-blur-sm">
            <h2 class="text-4xl text-red-500 font-black mb-4 italic">DISCONNECTED</h2>
            <p class="text-gray-400 mb-8 text-center">The host has left the game.</p>
            <button class="btn btn-primary w-48" onclick="window.leaveRoom()">RETURN TO MENU</button>
        </div>
    </div>
</div>

<script>
// --- FIELD & MECHANICS CONSTANTS ---
const FIELD_CONSTANTS = {
    COLOR_FIELD: '#2b2f3d',
    COLOR_BLUE: '#0066cc',
    COLOR_RED: '#cc0000',
    GOAL_HEIGHT: 170,
    GOAL_LINE_WIDTH: 7,
    CANVAS_WIDTH: 1000,
    CANVAS_HEIGHT: 600,
    BALL_RADIUS: 17,
    CAR_WIDTH: 50
};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const keys = {};

// Initialize Host Config
window.hostConfig = { mode: '1v1', type: 'timed', duration: 120, scoreTarget: 5, status: 'lobby' };

// --- STATE ---
let gameState = 'menu';
let cars = [];
let ball = null;
let boostPads = [];
let remoteEntities = {};
let score = { left: 0, right: 0 };
let lastTime = 0;
let localCar = null;
let gameTimer = 0; // Host-side timer
let lastBallHitTime = 0; 
let lastSyncSec = -1; // For 5-second sync check

window.onload = () => {
    canvas.width = FIELD_CONSTANTS.CANVAS_WIDTH;
    canvas.height = FIELD_CONSTANTS.CANVAS_HEIGHT;
    // Pre-initialize basic peer to be ready
    updateStatus(""); // Start hidden
};

// --- UI FUNCTIONS ---
function switchScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
}
window.switchScreen = switchScreen;

function validateName() {
    const n = document.getElementById('inp-name').value.trim();
    const err = document.getElementById('name-error');
    if(n.length < 3) { err.style.opacity = '1'; return null; }
    err.style.opacity = '0'; return n;
}
function goToModeSelect() { 
    const name = validateName(); 
    if(name) { 
        window.netState.user.username = name; 
        switchScreen('screen-mode'); 
    } 
}
function goToJoin() { 
    const name = validateName(); 
    if(name) { 
        window.netState.user.username = name; 
        // We init peer anonymously (random ID)
        updateStatus("Initializing Peer...", "text-yellow-400");
        initPeer().then(() => {
            switchScreen('screen-join');
        });
    } 
}
async function joinRoomAction() { 
    const code = document.getElementById('inp-room-code').value.trim().toUpperCase(); 
    if(code.length < 1) return alert("Enter Code"); 
    connectToHost(code);
}

// Host Setup Flow
function setHostMode(mode) { window.hostConfig.mode = mode; switchScreen('screen-type'); }
function setHostType(type) {
    window.hostConfig.type = type;
    const container = document.getElementById('limit-buttons');
    container.innerHTML = '';
    const title = document.getElementById('limit-title');
    const options = type === 'timed' 
        ? [{l:'1 MIN', v:60}, {l:'2 MIN', v:120}, {l:'5 MIN', v:300}] 
        : [{l:'3 PTS', v:3}, {l:'5 PTS', v:5}, {l:'10 PTS', v:10}];
    title.innerText = type === 'timed' ? 'SELECT DURATION' : 'SELECT SCORE LIMIT';
    options.forEach(opt => {
        const div = document.createElement('div');
        div.className = 'mode-card'; 
        div.style.width = '120px'; div.style.height = '100px';
        div.innerHTML = opt.l;
        div.onclick = () => finishHostSetup(opt.v);
        container.appendChild(div);
    });
    switchScreen('screen-limit');
}

window.finalizeCreateRoom = async () => {
    if(window.hostConfig.type === 'timed') window.hostConfig.duration = window.tempDuration;
    else window.hostConfig.scoreTarget = window.tempDuration;

    updateStatus("Creating Room...", "text-yellow-400");
    
    // Generate 6-char ID (Revised for safety)
    const roomId = Math.random().toString(36).substring(2, 8).toUpperCase().padEnd(6, 'X');
    
    try {
        await initPeer(roomId); // Try to claim this ID on PeerServer
        
        window.netState.isHost = true;
        window.netState.roomId = roomId;
        window.hostConfig.hostId = roomId;
        
        // Add Host as first player
        window.netState.players = [{
            roomId: roomId,
            userId: window.netState.myId,
            username: window.netState.user.username,
            isHost: true,
            isReady: false,
            slotIndex: -1,
            team: 'spectator'
        }];

        document.getElementById('lobby-code').innerText = roomId;
        window.updateLobbyUI(window.hostConfig);
        window.renderSlots(window.netState.players);
        window.switchScreen('screen-lobby');
        
    } catch(e) {
        console.error("Room creation failed", e);
        // Retry is handled in initPeer via recursion if ID taken
    }
};

function finishHostSetup(val) {
    window.tempDuration = val; // Store temp
    window.finalizeCreateRoom();
}

// --- LOBBY ACTIONS ---

window.leaveRoom = async () => {
    // --- CHANGED: FULL REFRESH ON LEAVE ---
    // This is the "refreshing thingy" that fixes second-game bugs.
    // By reloading the page, we ensure memory and peer connections are 100% clean.
    window.isIntentionalExit = true; 
    location.reload();
};

window.resetGameObjects = () => {
    gameState = 'menu';
    cars = []; ball = null; boostPads = []; score = {left:0, right:0};
    document.getElementById('lobby-code').innerText = '...';
    document.getElementById('slots-blue').innerHTML = '';
    document.getElementById('slots-red').innerHTML = '';
    document.getElementById('modal-exit').style.display = 'none';
    lastBallHitTime = 0;
};

function lobbyAction() {
    const uid = window.netState.myId;
    const me = window.netState.players.find(p => p.userId === uid);
    if(me && me.slotIndex !== -1) window.toggleReady();
}

window.claimSlot = (idx) => {
    const uid = window.netState.myId;
    const team = idx % 2 === 0 ? 'left' : 'right';
    
    if (window.netState.isHost) {
        // Host applies locally
        const me = window.netState.players.find(p => p.userId === uid);
        if(me) { me.slotIndex = idx; me.team = team; me.isReady = false; }
        broadcastToClients('LOBBY_STATE', { settings: window.hostConfig, players: window.netState.players, roomId: window.netState.roomId });
        window.renderSlots(window.netState.players);
    } else {
        // Client sends request
        sendToHost('SLOT_UPDATE', { action: 'claim', index: idx, team: team });
    }
};

window.toggleReady = () => {
    const uid = window.netState.myId;
    const me = window.netState.players.find(p => p.userId === uid);
    if (!me || me.slotIndex === -1) return;
    
    const newState = !me.isReady;
    if (window.netState.isHost) {
        me.isReady = newState;
        broadcastToClients('LOBBY_STATE', { settings: window.hostConfig, players: window.netState.players, roomId: window.netState.roomId });
        window.renderSlots(window.netState.players);
    } else {
        sendToHost('SLOT_UPDATE', { action: 'ready', state: newState });
    }
};

window.startGame = () => {
    if (!window.netState.isHost) return;
    window.hostConfig.status = 'playing';
    broadcastToClients('LOBBY_STATE', { settings: window.hostConfig, players: window.netState.players, roomId: window.netState.roomId });
    window.initGame(window.hostConfig);
};

function tryExitGame() { document.getElementById('modal-exit').style.display = 'flex'; }
function cancelExit() { document.getElementById('modal-exit').style.display = 'none'; }
function pauseGame() {
    if (!window.netState.isHost) return;
    const modal = document.getElementById('modal-pause');
    const isPaused = modal.style.display === 'flex';
    // Toggle locally
    if(isPaused) modal.style.display = 'none'; else modal.style.display = 'flex';
    // In P2P, pause is part of GAME_UPDATE sent every frame, so it will sync automatically
}


// --- RENDERERS ---
window.updateLobbyUI = (data) => {
    window.hostConfig = data;
    document.getElementById('info-mode').innerText = `MODE: ${data.mode}`;
    document.getElementById('info-type').innerText = `TYPE: ${data.type.toUpperCase()}`;
    document.getElementById('info-limit').innerText = `LIMIT: ${data.type==='timed'?(data.duration/60)+' MIN':data.scoreTarget + ' PTS'}`;
};

window.renderSlots = (players) => {
    const slotsBlue = document.getElementById('slots-blue');
    const slotsRed = document.getElementById('slots-red');
    slotsBlue.innerHTML = ''; slotsRed.innerHTML = '';
    
    const mode = window.hostConfig.mode || '1v1';
    const count = mode === '2v2' ? 4 : (mode === '3v3' ? 6 : 2);
    const uid = window.netState.myId;
    const me = players.find(p => p.userId === uid);
    
    const btn = document.getElementById('btn-lobby-action');
    const startBtn = document.getElementById('btn-host-start');
    const hostWarning = document.getElementById('host-warning');
    
    if(window.netState.isHost) {
        const readyCount = players.filter(p => p.slotIndex !== -1 && p.isReady).length;
        const totalHumans = players.filter(p => p.slotIndex !== -1).length;
        const hostInSlot = me && me.slotIndex !== -1;
        startBtn.style.display = 'block';
        if (hostInSlot && totalHumans > 0 && readyCount === totalHumans) {
            startBtn.disabled = false; startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            hostWarning.style.display = 'none';
        } else {
            startBtn.disabled = true; startBtn.classList.add('opacity-50', 'cursor-not-allowed');
            if (!hostInSlot) hostWarning.style.display = 'block'; else hostWarning.style.display = 'none';
        }
    } else { startBtn.style.display = 'none'; hostWarning.style.display = 'none'; }

    if(me && me.slotIndex !== -1) {
        btn.innerText = me.isReady ? "READY!" : "CLICK TO READY UP";
        btn.className = `btn w-80 shadow-xl ${me.isReady ? 'bg-green-500 hover:bg-green-400 text-white' : 'btn-primary'}`;
    } else {
        btn.innerText = "JOIN A SLOT FIRST";
        btn.className = "btn btn-outline w-80 text-gray-500 border-gray-500 cursor-not-allowed";
    }

    for(let i=0; i<count; i++) {
        const isRed = i % 2 !== 0;
        const container = isRed ? slotsRed : slotsBlue;
        const p = players.find(pl => pl.slotIndex === i);
        const div = document.createElement('div');
        if(p) {
            div.className = `slot filled ${isRed?'red':'blue'}`;
            div.innerHTML = `<div class="flex items-center gap-3"><div class="text-white font-bold text-lg uppercase">${p.username}</div>${p.isHost ? '<span class="text-xxs bg-yellow-500 text-black px-1 rounded font-bold">HOST</span>' : ''}</div><div class="px-2 py-1 rounded text-xs font-bold ${p.isReady ? 'bg-green-500 text-white' : 'bg-yellow-500/50 text-yellow-100'}">${p.isReady ? 'READY' : 'WAITING'}</div>`;
        } else {
            div.className = "slot ai";
            div.innerHTML = `<div class="text-gray-400 font-bold flex items-center gap-2"><span>ü§ñ</span> AI BOT</div><div class="text-xs text-gray-500 font-bold border border-gray-600 px-2 py-1 rounded hover:bg-gray-700 hover:text-white">JOIN</div>`;
            div.onclick = () => window.claimSlot(i);
        }
        container.appendChild(div);
    }
};

// --- GAME MECHANICS ---

function drawField(ctx, canvas) {
    ctx.fillStyle = FIELD_CONSTANTS.COLOR_FIELD;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let goalHeight = FIELD_CONSTANTS.GOAL_HEIGHT;
    let playerGoalTop = canvas.height / 2 - goalHeight / 2;
    let playerGoalBottom = canvas.height / 2 + goalHeight / 2;

    ctx.fillStyle = 'rgba(0, 102, 204, 0.2)';
    ctx.fillRect(0, playerGoalTop, 20, goalHeight);
    ctx.fillStyle = 'rgba(204, 0, 0, 0.2)';
    ctx.fillRect(canvas.width - 20, playerGoalTop, 20, goalHeight);

    ctx.strokeStyle = "#dcdcdc"; ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height); ctx.stroke();
    ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, 80, 0, Math.PI * 2); ctx.stroke();
    
    ctx.strokeStyle = FIELD_CONSTANTS.COLOR_BLUE; ctx.lineWidth = FIELD_CONSTANTS.GOAL_LINE_WIDTH;
    ctx.beginPath(); ctx.moveTo(0, playerGoalTop); ctx.lineTo(0, playerGoalBottom); ctx.stroke();
    ctx.strokeStyle = FIELD_CONSTANTS.COLOR_RED;
    ctx.beginPath(); ctx.moveTo(canvas.width, playerGoalTop); ctx.lineTo(canvas.width, playerGoalBottom); ctx.stroke();
}

function checkGoal(ball, canvas) {
    let goalHeight = FIELD_CONSTANTS.GOAL_HEIGHT + 20; 
    let goalTop = canvas.height/2 - goalHeight/2;
    let goalBottom = canvas.height/2 + goalHeight/2;
    
    // Check Left Goal (Blue's Net -> Red Scores)
    if (ball.y > goalTop && ball.y < goalBottom && ball.x - ball.radius <= 5) { 
        return 'right';
    }
    // Check Right Goal (Red's Net -> Blue Scores)
    if (ball.y > goalTop && ball.y < goalBottom && ball.x + ball.radius >= canvas.width - 5) { 
        return 'left';
    }
    return null;
}

// --- ENTITIES ---
class BoostPad {
    constructor(x, y) { this.x=x; this.y=y; this.active=true; this.cooldown=0; this.radius=15; }
    update(dt) { if(!this.active) { this.cooldown-=dt; if(this.cooldown<=0) this.active=true; } }
    draw() {
        ctx.save(); ctx.globalAlpha = this.active ? 1 : 0.3;
        ctx.fillStyle = '#fbbf24'; ctx.shadowBlur = this.active ? 10 : 0; ctx.shadowColor = '#fbbf24';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius*0.6, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }
}

class Car {
    constructor(id, x, y, angle, team, isLocal, isAI, ownerId) {
        this.id = id; this.x = x; this.y = y; this.angle = angle;
        this.team = team; this.isLocal = isLocal; this.isAI = isAI; this.ownerId = ownerId;
        this.velX=0; this.velY=0; this.baseAcceleration=0.3; this.baseMaxSpeed=5.0;
        this.baseRotationSpeed=3.0; 
        
        this.baseSideFrictionFactor=0.05;
        this.boostPower=1.8; this.boost=100; 
        this.width=50; this.height=25;
        this.color=team==='left'?'#0066cc':'#cc0000'; this.boosting=false;
        this.role='attacker'; this.isFriendlyAI=(team==='left'); this.aiThrottle=0;
        this.aiStuckState='none'; this.aiStuckStateTimer=0; this.stuckThresholdDist=150;
        this.difficulty=3;
    }
    update(dt) {
        if (this.isLocal) {
            let throttle = 0;
            if (keys['KeyW'] || keys['ArrowUp']) throttle = 1;
            else if (keys['KeyS'] || keys['ArrowDown']) throttle = -1;
            if (keys['KeyA'] || keys['ArrowLeft']) this.angle = (this.angle + this.baseRotationSpeed) % 360;
            if (keys['KeyD'] || keys['ArrowRight']) this.angle = (this.angle - this.baseRotationSpeed) % 360;
            const shift = keys['ShiftLeft'] || keys['ShiftRight'];
            this.boosting = !!(shift && this.boost > 0);
            
            let rad = Math.PI * this.angle / 180;
            let fVel = this.velX*Math.cos(rad) - this.velY*Math.sin(rad);
            let sVel = this.velX*Math.sin(rad) + this.velY*Math.cos(rad);
            if (throttle !== 0) fVel += throttle * this.baseAcceleration;
            if (this.boosting) { fVel += this.baseAcceleration * this.boostPower * (throttle || 1); this.boost = Math.max(0, this.boost - 1.0); }
            fVel *= 0.96; sVel *= (1 - this.baseSideFrictionFactor);
            this.velX = fVel * Math.cos(rad) + sVel * Math.sin(rad);
            this.velY = -fVel * Math.sin(rad) + sVel * Math.cos(rad);
            let speed = Math.hypot(this.velX, this.velY);
            let max = this.baseMaxSpeed * (this.boosting ? this.boostPower : 1);
            if (speed > max) { let scale = max/speed; this.velX*=scale; this.velY*=scale; }
            this.x += this.velX * dt * 60; this.y += this.velY * dt * 60;

            let mw = this.width/2, mh = this.height/2;
            if (this.x < mw) { this.x = mw; this.velX *= -0.5; }
            if (this.x > FIELD_CONSTANTS.CANVAS_WIDTH - mw) { this.x = FIELD_CONSTANTS.CANVAS_WIDTH - mw; this.velX *= -0.5; }
            if (this.y < mh) { this.y = mh; this.velY *= -0.5; }
            if (this.y > FIELD_CONSTANTS.CANVAS_HEIGHT - mh) { this.y = FIELD_CONSTANTS.CANVAS_HEIGHT - mh; this.velY *= -0.5; }

            // BOOST PAD LOGIC (CLIENT SIDE SEND)
            boostPads.forEach((pad, index) => {
                if (pad.active && Math.hypot(this.x-pad.x, this.y-pad.y) < this.width/2 + pad.radius) {
                    this.boost = Math.min(100, this.boost + 20);
                    pad.active = false; pad.cooldown = 5.0;
                    // NOTIFY HOST
                    if (!window.netState.isHost) {
                        sendToHost('BOOST_TAKEN', { index: index });
                    }
                }
            });
        } 
        else if (this.isAI && window.netState.isHost) {
            // Host runs AI Physics
            this.handleAI(dt, ball, cars);
            let rad = Math.PI * this.angle / 180;
            let fVel = this.velX*Math.cos(rad) - this.velY*Math.sin(rad);
            let sVel = this.velX*Math.sin(rad) + this.velY*Math.cos(rad);
            let throttle = this.aiThrottle;
            if (throttle !== 0) fVel += throttle * this.baseAcceleration;
            if (this.boosting) { fVel += this.baseAcceleration * this.boostPower * (throttle || 1); this.boost = Math.max(0, this.boost - 1.0); }
            fVel *= 0.96; sVel *= (1 - this.baseSideFrictionFactor);
            this.velX = fVel * Math.cos(rad) + sVel * Math.sin(rad);
            this.velY = -fVel * Math.sin(rad) + sVel * Math.cos(rad);
            let speed = Math.hypot(this.velX, this.velY);
            let max = this.baseMaxSpeed * (this.boosting ? this.boostPower : 1);
            if (speed > max) { let scale = max/speed; this.velX*=scale; this.velY*=scale; }
            this.x += this.velX * dt * 60; this.y += this.velY * dt * 60;

            let mw = this.width/2, mh = this.height/2;
            if (this.x < mw) { this.x = mw; this.velX *= -0.5; }
            if (this.x > FIELD_CONSTANTS.CANVAS_WIDTH - mw) { this.x = FIELD_CONSTANTS.CANVAS_WIDTH - mw; this.velX *= -0.5; }
            if (this.y < mh) { this.y = mh; this.velY *= -0.5; }
            if (this.y > FIELD_CONSTANTS.CANVAS_HEIGHT - mh) { this.y = FIELD_CONSTANTS.CANVAS_HEIGHT - mh; this.velY *= -0.5; }
        }
        else {
            // REMOTE PLAYER or AI (Client Side)
            const data = remoteEntities[this.id];
            if (data) {
                // Lerp for smoothness
                this.x += (data.x - this.x) * 0.5;
                this.y += (data.y - this.y) * 0.5;
                let d = data.angle - this.angle;
                while (d < -180) d += 360; while (d > 180) d -= 360;
                this.angle += d * 0.5;
                this.boost = data.boost || 100; this.boosting = data.boosting || false;
            }
        }
    }
    handleAI(dt, ball, allCars) {
        if (!ball) return;
        this.aiThrottle = 0;
        if (this.aiStuckState !== 'none') { this.runStuckRoutine(dt, ball); this.aiThrottle = this.throttleDirection; return; }
        let thresh = this.stuckThresholdDist;
        const inDanger = (this.x < thresh || this.x > FIELD_CONSTANTS.CANVAS_WIDTH - thresh || this.y < thresh || this.y > FIELD_CONSTANTS.CANVAS_HEIGHT - thresh);
        if (inDanger && Math.hypot(this.velX, this.velY) < 2.0) {
             this.stuckInCornerTimer += dt;
             if (this.stuckInCornerTimer > 1.5) { this.aiStuckState = 'reversing'; this.aiStuckStateTimer = 0.4; return; }
        } else { this.stuckInCornerTimer = 0; }
        let teammates = allCars.filter(c => c.team === this.team);
        teammates.sort((a, b) => Math.hypot(a.x - ball.x, a.y - ball.y) - Math.hypot(b.x - ball.x, b.y - ball.y));
        let amIClosest = (teammates[0] === this);
        let tx, ty;
        if (amIClosest) { tx = ball.x; ty = ball.y; } 
        else {
            if (this.role === 'attacker') { tx = FIELD_CONSTANTS.CANVAS_WIDTH/2; ty = ball.y > FIELD_CONSTANTS.CANVAS_HEIGHT/2 ? FIELD_CONSTANTS.CANVAS_HEIGHT*0.3 : FIELD_CONSTANTS.CANVAS_HEIGHT*0.7; }
            else if (this.role === 'mid') { tx = (ball.x + (this.team==='right'?FIELD_CONSTANTS.CANVAS_WIDTH:0))/2; ty = (ball.y + FIELD_CONSTANTS.CANVAS_HEIGHT/2)/2; }
            else { tx = ball.x; ty = ball.y; }
        }
        if (this.role === 'defender') {
            let gx = this.isFriendlyAI ? FIELD_CONSTANTS.BALL_RADIUS*3 : FIELD_CONSTANTS.CANVAS_WIDTH - FIELD_CONSTANTS.BALL_RADIUS*3;
            if (!amIClosest) { tx = gx; ty = Math.max(FIELD_CONSTANTS.CANVAS_HEIGHT/2-FIELD_CONSTANTS.GOAL_HEIGHT/2+20, Math.min(ball.y, FIELD_CONSTANTS.CANVAS_HEIGHT/2+FIELD_CONSTANTS.GOAL_HEIGHT/2-20)); }
            else { if(Math.abs(ball.x - gx) < 400) { tx = ball.x; ty = ball.y; } else { tx = gx; ty = Math.max(FIELD_CONSTANTS.CANVAS_HEIGHT/2-FIELD_CONSTANTS.GOAL_HEIGHT/2+20, Math.min(ball.y, FIELD_CONSTANTS.CANVAS_HEIGHT/2+FIELD_CONSTANTS.GOAL_HEIGHT/2-20)); } }
        }
        const dx = tx - this.x, dy = ty - this.y;
        const targetRad = Math.atan2(-dy, dx);
        let targetAngle = (targetRad * 180 / Math.PI + 360) % 360;
        let diff = targetAngle - this.angle;
        if (diff > 180) diff -= 360; if (diff < -180) diff += 360;
        if (diff > this.baseRotationSpeed) this.angle = (this.angle + this.baseRotationSpeed) % 360;
        else if (diff < -this.baseRotationSpeed) this.angle = (this.angle - this.baseRotationSpeed) % 360;
        else this.angle = targetAngle;
        this.throttleDirection = 0;
        if (Math.abs(diff) < 32) {
            this.throttleDirection = 1;
            let rad = Math.PI * this.angle / 180;
            this.velX += Math.cos(rad) * this.baseAcceleration; this.velY -= Math.sin(rad) * this.baseAcceleration;
        }
        this.aiThrottle = this.throttleDirection;
        let dist = Math.hypot(dx, dy);
        this.boosting = (this.difficulty > 5 && Math.abs(diff) < 10 && dist > 150 && this.boost > 20) || (this.role === 'defender' && dist > 300);
    }
    runStuckRoutine(dt, ball) {
        this.aiStuckStateTimer -= dt;
        if (this.aiStuckState === 'reversing') { this.throttleDirection = -1; if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'wall_seek'; this.aiStuckStateTimer = 0.5; } }
        else if (this.aiStuckState === 'wall_seek') { this.throttleDirection = 1; if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'turn_ball'; this.aiStuckStateTimer = 0.4; } }
        else if (this.aiStuckState === 'turn_ball') { if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'hit_ball'; this.aiStuckStateTimer = 0.4; } }
        else if (this.aiStuckState === 'hit_ball') { this.throttleDirection = 1; if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'reversing_small'; this.aiStuckStateTimer = 0.3; } }
        else if (this.aiStuckState === 'reversing_small') { this.throttleDirection = -1; if (this.aiStuckStateTimer <= 0) { this.aiStuckState = 'none'; this.stuckInCornerTimer = 0; } }
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); 
        ctx.save();
        ctx.rotate(-this.angle * Math.PI / 180);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.roundRect(-25, -13, 50, 26, 4); ctx.fill();
        ctx.fillStyle = '#1f2937'; ctx.beginPath(); ctx.roundRect(-5, -10, 20, 20, 2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(-25, -3, 50, 6);
        ctx.fillStyle = this.color; ctx.beginPath(); ctx.roundRect(-28, -15, 6, 30, 2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.fillRect(-20, -15, 12, 4); ctx.fillRect(10, -15, 12, 4); ctx.fillRect(-20, 11, 12, 4); ctx.fillRect(10, 11, 12, 4); 
        if (this.boosting) {
            ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.moveTo(-28, 0); ctx.lineTo(-50 - Math.random()*10, -8); ctx.lineTo(-50 - Math.random()*10, 8); ctx.fill();
            ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.moveTo(-28, 0); ctx.lineTo(-40 - Math.random()*5, -4); ctx.lineTo(-40 - Math.random()*5, 4); ctx.fill();
        }
        ctx.restore();
        ctx.fillStyle = '#374151'; 
        ctx.fillRect(-20, -35, 40, 6);
        ctx.fillStyle = this.boost > 50 ? '#fbbf24' : (this.boost > 20 ? '#f59e0b' : '#ef4444');
        ctx.fillRect(-19, -34, 38 * (this.boost/100), 4);

        ctx.fillStyle = 'white'; ctx.font = '10px Inter'; ctx.textAlign = 'center';
        const p = window.netState.players.find(pl => pl.userId === this.ownerId);
        ctx.fillText(this.isAI ? `AI` : (p ? p.username : 'P'), 0, -40);
        ctx.restore();
    }
}

class Ball {
    constructor(x, y) { 
        this.x=x; this.y=y; this.velX=0; this.velY=0; this.radius=FIELD_CONSTANTS.BALL_RADIUS; 
        this.val = 1;
    }
    
    update(dt) {
        // HOST controls Ball Physics authoritative
        if (window.netState.isHost) {
            this.x += this.velX*dt*60; this.y += this.velY*dt*60;
            this.velX *= 0.98; this.velY *= 0.98;
            
            const goalHeight = FIELD_CONSTANTS.GOAL_HEIGHT;
            const goalTop = canvas.height / 2 - goalHeight / 2; // FIX: Correct var usage
            const goalBottom = canvas.height / 2 + goalHeight / 2;
            // FIX: Allow ball to enter goal more easily
            const inGoalY = this.y >= goalTop - 10 && this.y <= goalBottom + 10;

            if (this.y<this.radius) { this.y=this.radius; this.velY*=-0.8; }
            if (this.y>FIELD_CONSTANTS.CANVAS_HEIGHT-this.radius) { this.y=FIELD_CONSTANTS.CANVAS_HEIGHT-this.radius; this.velY*=-0.8; }
            if (this.x<this.radius && !inGoalY) { this.x=this.radius; this.velX*=-0.8; }
            if (this.x>FIELD_CONSTANTS.CANVAS_WIDTH-this.radius && !inGoalY) { this.x=FIELD_CONSTANTS.CANVAS_WIDTH-this.radius; this.velX*=-0.8; }
        } else {
            // Client lerps ball from host data BUT uses velocity for prediction
            const d = remoteEntities['ball'];
            if(d) { 
                this.x += (d.x - this.x) * 0.3; 
                this.y += (d.y - this.y) * 0.3;
                // Update velocity if provided for improved prediction
                if (d.velX !== undefined) this.velX = d.velX;
                if (d.velY !== undefined) this.velY = d.velY;
                
                // Simple client-side prediction
                this.x += this.velX * dt * 0.5; // Weak prediction to smooth
                this.y += this.velY * dt * 0.5;

                this.val = d.val || 1;
            }
        }
    }
    
    draw() {
        if(this.val === 3) ctx.fillStyle = '#ffd700';
        else if(this.val === 2) ctx.fillStyle = '#a855f7';
        else ctx.fillStyle = '#00fff4';

        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.beginPath(); ctx.arc(this.x-5, this.y-5, 6, 0, Math.PI*2); ctx.fill();
        
        if(this.val > 1) {
            ctx.fillStyle = '#000'; ctx.font = 'bold 14px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(`x${this.val}`, this.x, this.y);
        }
    }
}

window.initGame = (roomData) => {
    gameState = 'playing';
    document.getElementById('app').classList.add('in-game');
    switchScreen('screen-game');
    cars = []; boostPads = []; score = {left:0, right:0};
    // FIX: Ensure score is visually reset immediately
    document.getElementById('score-left').innerText = '0';
    document.getElementById('score-right').innerText = '0';
    
    // FIX: Ensure timer is set
    gameTimer = (roomData.type === 'timed' && roomData.duration) ? roomData.duration : 0; 
    lastBallHitTime = 0;
    lastSyncSec = -1;
    
    // FIX: Hide timer if Points Mode
    const tBox = document.getElementById('game-timer');
    if (roomData.type === 'points') {
        tBox.classList.add('hidden-mode');
    } else {
        tBox.classList.remove('hidden-mode');
    }
    
    const padLocs = [{x: 200, y: 200}, {x: 800, y: 200}, {x: 200, y: 400}, {x: 800, y: 400}, {x: 500, y: 100}, {x: 500, y: 500}];
    padLocs.forEach(p => boostPads.push(new BoostPad(p.x, p.y)));

    const count = roomData.mode === '2v2' ? 4 : (roomData.mode === '3v3' ? 6 : 2);
    const players = window.netState.players;
    let aiCars = [];

    for (let i = 0; i < count; i++) {
        const p = players.find(pl => pl.slotIndex === i);
        const isRed = i % 2 !== 0;
        const startX = isRed ? 900 : 100;
        const startY = 300 + (Math.floor(i/2) * 80 * (i%4==0?1:-1));
        const angle = isRed ? 180 : 0;
        
        let id;
        if (p) id = p.userId;
        else id = `ai_${i}`;

        const team = isRed ? 'right' : 'left';
        
        const isMe = p && p.userId === window.netState.myId;
        const isAI = !p;
        const ownerId = p ? p.userId : window.netState.roomId; 

        const newCar = new Car(id, startX, startY, angle, team, isMe, isAI, ownerId);
        newCar.resetPos = {x: startX, y: startY, angle: angle};
        cars.push(newCar);
        if(isMe) localCar = newCar;
        if(isAI) aiCars.push(newCar);
    }
    
    aiCars.sort((a, b) => a.id.localeCompare(b.id)).forEach((ai, idx) => {
        const roles = ["attacker", "defender", "mid", "attacker", "mid", "defender"];
        ai.role = roles[idx % roles.length];
    });
    
    ball = new Ball(500, 300);
    lastTime = Date.now();
    loop();
};

window.handleGameStateUpdate = (data) => {
    if (data.ball) {
        remoteEntities['ball'] = data.ball;
    }
    if (data.padStates) {
        data.padStates.forEach((cooldown, i) => {
            if(boostPads[i]) {
                boostPads[i].cooldown = cooldown;
                boostPads[i].active = (cooldown <= 0);
            }
        });
    }
    if (data.scores) { 
        document.getElementById('score-left').innerText = data.scores.left; 
        document.getElementById('score-right').innerText = data.scores.right; 
        score = data.scores;
    }
    
    if (data.winner) {
        if (gameState === 'finished') return; 
        const myUid = window.netState.myId;
        const me = window.netState.players.find(p => p.userId === myUid);
        const myTeam = me ? me.team : 'spectator';
        const title = document.getElementById('result-title');
        
        document.getElementById('end-score-blue').innerText = score.left;
        document.getElementById('end-score-red').innerText = score.right;
        
        if (data.winner === 'draw') {
             title.innerText = "DRAW";
             title.className = "text-8xl font-black italic tracking-tighter mb-2 text-white";
        } else if (myTeam === 'spectator') {
             title.innerText = data.winner.toUpperCase() + " WINS";
             title.className = "text-8xl font-black italic tracking-tighter mb-2 text-white";
        } else {
             const won = (data.winner === myTeam);
             title.innerText = won ? "YOU WIN" : "YOU LOSE";
             const colorClass = myTeam === 'left' ? 'text-blue-500' : 'text-red-500';
             title.className = `text-8xl font-black italic tracking-tighter mb-2 ${colorClass}`;
        }
        
        gameState = 'finished';
        switchScreen('screen-result');
    }

    // FIX: Handle Timer Updates
    if (data.timer !== undefined) { 
        // Sync Logic: Only overwrite local timer if forced (Goal or 5s Sync) or if drift is crazy
        if (data.forceSync || Math.abs(gameTimer - data.timer) > 10) {
            gameTimer = data.timer;
        }

        // Helper handled in Loop for smoothness, but we update once here to prevent jump
        const tBox = document.getElementById('game-timer');
        // (Optional logic removed here as loop handles it now)
    }
    if (data.paused !== undefined) { 
        const m = document.getElementById('modal-pause'); 
        if(data.paused) m.style.display = 'flex'; 
        else m.style.display = 'none'; 
    }
};

window.handleRemoteEntityUpdate = (data) => { 
    Object.keys(data).forEach(k => remoteEntities[k] = data[k]); 
};

// --- GAME LOOP ---
function loop() {
    requestAnimationFrame(loop);
    if (gameState !== 'playing') return;

    const now = Date.now(), dt = (now - lastTime) / 1000;
    lastTime = now;
    
    drawField(ctx, canvas);

    const isPaused = document.getElementById('modal-pause').style.display === 'flex';

    if (!isPaused) {
        // --- LOCAL TIMER UPDATE (For Everyone) ---
        if (window.hostConfig.type === 'timed') {
            gameTimer -= dt;
            if (gameTimer < 0) gameTimer = 0;
            
            // FIX: FORCE UI UPDATE EVERY FRAME
            const tBox = document.getElementById('game-timer');
            const duration = window.hostConfig.duration || 120;
            const isHalf = Math.abs(gameTimer - duration/2) < 0.5;
            const is30 = Math.abs(gameTimer - 30) < 0.5;
            
            if (gameTimer <= 10 && gameTimer > 0) {
                tBox.classList.add('countdown');
                tBox.classList.remove('glow-red'); // Prioritize countdown style
                tBox.innerText = Math.ceil(gameTimer); 
            } else {
                tBox.classList.remove('countdown');
                const m = Math.floor(gameTimer/60), s = Math.floor(gameTimer%60); 
                tBox.innerText = `${m}:${s<10?'0'+s:s}`;
                
                // Flashing Logic
                if (isHalf || is30) {
                    if (!tBox.dataset.flashed) {
                        tBox.classList.add('glow-red');
                        tBox.dataset.flashed = "true";
                        // Auto-remove flash after 1s
                        setTimeout(() => tBox.classList.remove('glow-red'), 1000);
                    }
                } else {
                    tBox.dataset.flashed = "";
                }
            }
        }

        // --- HOST LOGIC: MASTER GAME STATE ---
        if (window.netState.isHost) {
            if (window.hostConfig.type === 'timed') {
                if (gameTimer <= 0) {
                    gameTimer = 0;
                    let winner = 'draw';
                    if (score.left > score.right) winner = 'left';
                    if (score.right > score.left) winner = 'right';
                    
                    const endGamePayload = { winner: winner, scores: score, timer: 0, paused: false, forceSync: true };
                    window.handleGameStateUpdate(endGamePayload);
                    broadcastToClients('GAME_UPDATE', endGamePayload);
                    return; 
                }
            }
        }

        boostPads.forEach(p => { p.update(dt); p.draw(); });
        ball.update(dt); // Host runs phys, Client lerps
        
        const myUpdateData = {};
        
        // FIX: Improved collision physics
        for (let i = 0; i < cars.length; i++) {
             for (let j = i + 1; j < cars.length; j++) {
                const c1 = cars[i], c2 = cars[j];
                const dist = Math.hypot(c1.x - c2.x, c1.y - c2.y);
                const minDist = 45; 
                if (dist < minDist) {
                    const angle = Math.atan2(c1.y - c2.y, c1.x - c2.x);
                    const overlap = minDist - dist;
                    const pushX = Math.cos(angle) * overlap * 0.5;
                    const pushY = Math.sin(angle) * overlap * 0.5;

                    // FIX: Only move cars that WE control locally. 
                    // Treat remote cars as solid walls. This prevents "jitter" where you push them and they snap back.
                    
                    if (c1.isLocal || (window.netState.isHost && c1.isAI)) {
                        c1.x += pushX; c1.y += pushY; 
                        // Bounce off the other car
                        c1.velX += Math.cos(angle) * 3; c1.velY += Math.sin(angle) * 3;
                        // Slow down slightly on impact
                        c1.velX *= 0.8; c1.velY *= 0.8;
                    }
                    
                    if (c2.isLocal || (window.netState.isHost && c2.isAI)) {
                        c2.x -= pushX; c2.y -= pushY; 
                         // Bounce off the other car
                        c2.velX -= Math.cos(angle) * 3; c2.velY -= Math.sin(angle) * 3;
                         // Slow down slightly on impact
                        c2.velX *= 0.8; c2.velY *= 0.8;
                    }
                }
            }
        }

        cars.forEach(c => {
            c.update(dt); c.draw();
            
            // HIT BALL LOGIC
            if (c.isLocal || (window.netState.isHost && c.isAI)) {
                
                // Prepare data to send
                if (c.isLocal) {
                    myUpdateData[c.id] = { 
                        x: Math.round(c.x), y: Math.round(c.y), 
                        angle: Math.round(c.angle), boost: Math.round(c.boost), 
                        boosting: !!c.boosting 
                    };
                } else if (c.isAI) {
                     // Host sends AI data too
                     myUpdateData[c.id] = { 
                        x: Math.round(c.x), y: Math.round(c.y), 
                        angle: Math.round(c.angle), boost: Math.round(c.boost), 
                        boosting: !!c.boosting 
                    };
                }

                // Ball Collision
                const dx = ball.x - c.x, dy = ball.y - c.y, dist = Math.hypot(dx, dy);
                if (dist < FIELD_CONSTANTS.BALL_RADIUS + 50/2) {
                    const angle = Math.atan2(dy, dx), overlap = (FIELD_CONSTANTS.BALL_RADIUS + 50/2) - dist;
                    c.x -= Math.cos(angle) * overlap; c.y -= Math.sin(angle) * overlap;
                    c.velX -= Math.cos(angle) * 5; c.velY -= Math.sin(angle) * 5;
                    
                    // Modify ball locally (Host will authoritative override, Clients will predict)
                    ball.velX += Math.cos(angle) * 15; 
                    ball.velY += Math.sin(angle) * 15;

                    // --- NEW: Send Physics Data to Host immediately ---
                    if (!window.netState.isHost && c.isLocal) {
                        sendToHost('BALL_HIT', { 
                            x: ball.x, y: ball.y, 
                            velX: ball.velX, velY: ball.velY 
                        });
                    }
                }
            }
        });
        ball.draw();
        
        if (localCar) {
            document.getElementById('boost-fill').style.width = localCar.boost + '%';
            document.getElementById('boost-bar-container').style.display = 'block';
        } else { document.getElementById('boost-bar-container').style.display = 'none'; }

        // --- NETWORK SYNC ---
        const nowMs = Date.now();
        if (nowMs - window.netState.lastUpdateSent > 30) { // 30 FPS updates (Faster than Firebase!)
            window.netState.lastUpdateSent = nowMs;
            
            // Clients send their Car
            if (!window.netState.isHost && localCar) {
                 sendToHost('ENTITY_UPDATE', myUpdateData);
            }
            
            // Host sends EVERYTHING (AI Cars + Their Car + Ball + GameState + Pads)
            if (window.netState.isHost) {
                 // Check 5 second interval
                 let isSyncFrame = false;
                 const currentSec = Math.floor(gameTimer);
                 if (currentSec % 5 === 0 && currentSec !== lastSyncSec) {
                     isSyncFrame = true;
                     lastSyncSec = currentSec;
                 }

                 const gameStatePayload = { 
                     scores: score, 
                     timer: gameTimer, 
                     paused: isPaused,
                     forceSync: isSyncFrame, // Tell clients to snap time
                     padStates: boostPads.map(p => p.cooldown) // SYNC MAP DATA
                 };

                 // Add Ball to entities
                 myUpdateData['ball'] = { 
                     x: Math.round(ball.x), y: Math.round(ball.y), 
                     velX: ball.velX, velY: ball.velY, // SYNC VELOCITY
                     val: ball.val 
                 };
                 
                 // Send Entity Updates (Car + AI + Ball)
                 broadcastToClients('ENTITY_UPDATE', myUpdateData);
                 // Send Game Logic (Timer + Scores + Map)
                 broadcastToClients('GAME_UPDATE', gameStatePayload);
            }
        }
        
        // --- HOST: GOAL CHECKING ---
        if (window.netState.isHost) {
            const scoringTeam = checkGoal(ball, canvas);
            if (scoringTeam) {
                const points = ball.val; 
                if (scoringTeam === 'left') score.left += points;
                if (scoringTeam === 'right') score.right += points;
                
                // Reset
                ball.x = 500; 
                ball.y = 150 + Math.random() * 300;
                ball.velX = 0; ball.velY = 0; 
                cars.forEach(c => {
                    if(c.resetPos) { c.x = c.resetPos.x; c.y = c.resetPos.y; c.angle = c.resetPos.angle; c.velX = 0; c.velY = 0; c.boost = 100; }
                });

                // UPDATE HOST UI IMMEDIATELY
                window.handleGameStateUpdate({ scores: score });

                // Win Check
                if (window.hostConfig.type === 'points' && (score.left >= window.hostConfig.scoreTarget || score.right >= window.hostConfig.scoreTarget)) {
                    let winner = score.left >= window.hostConfig.scoreTarget ? 'left' : 'right';
                    const endGamePayload = { winner: winner, scores: score, timer: 0, paused: false, forceSync: true };
                    window.handleGameStateUpdate(endGamePayload);
                    broadcastToClients('GAME_UPDATE', endGamePayload);
                    return; 
                }

                // Next Round Ball
                const rand = Math.random();
                if (rand < 0.05) ball.val = 3; 
                else if (rand < 0.15) ball.val = 2; 
                else ball.val = 1;
                
                // Force sync immediately on goal - THIS ENSURES ALL PLAYERS SEE NEW SCORE INSTANTLY
                broadcastToClients('GAME_UPDATE', { scores: score, timer: gameTimer, paused: isPaused, forceSync: true, padStates: boostPads.map(p=>p.cooldown) });
                broadcastToClients('ENTITY_UPDATE', { 'ball': { x: ball.x, y: ball.y, velX: 0, velY: 0, val: ball.val } });
            }
        }
    }
}

window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);
</script>
</body>
</html>
